<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°æ®åˆ†å¸ƒè½¬æ¢å·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
        }

        .control-group select,
        .control-group input[type="file"],
        .control-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .file-upload {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-upload input[type="file"] {
            cursor: pointer;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .chart-wrapper {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .chart-wrapper h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #495057;
        }

        .chart-canvas {
            background: white;
            border-radius: 5px;
            padding: 10px;
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat-card .label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-card .value {
            font-size: 24px;
            font-weight: 700;
            color: #495057;
            margin-top: 5px;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h4 {
            color: #1976D2;
            margin-bottom: 10px;
        }

        .param-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š æ•°æ®åˆ†å¸ƒè½¬æ¢å·¥å…·</h1>
            <p>æ”¯æŒå¤šç§ç»Ÿè®¡å˜æ¢æ–¹æ³•ï¼Œå®æ—¶å¯è§†åŒ–æ•°æ®åˆ†å¸ƒ</p>
        </div>

        <div class="content">
            <div class="control-panel">
                <div class="control-group">
                    <label for="fileInput">ä¸Šä¼  CSV æ–‡ä»¶</label>
                    <input type="file" id="fileInput" accept=".csv">
                </div>

                <div class="control-group">
                    <label for="columnSelect">é€‰æ‹©ç‰¹å¾åˆ—</label>
                    <select id="columnSelect" disabled>
                        <option>è¯·å…ˆä¸Šä¼ CSVæ–‡ä»¶</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="transformSelect">å˜æ¢ç±»å‹</label>
                    <select id="transformSelect" disabled>
                        <option value="log">å¯¹æ•°å˜æ¢ (Log Transform)</option>
                        <option value="log1p">Log1på˜æ¢ (log(1+x))</option>
                        <option value="sqrt">å¹³æ–¹æ ¹å˜æ¢ (Square Root)</option>
                        <option value="boxcox">Box-Coxå˜æ¢</option>
                        <option value="yeojohnson">Yeo-Johnsonå˜æ¢</option>
                        <option value="quantile_normal">åˆ†ä½æ•°å˜æ¢ â†’ æ­£æ€åˆ†å¸ƒ</option>
                        <option value="quantile_uniform">åˆ†ä½æ•°å˜æ¢ â†’ å‡åŒ€åˆ†å¸ƒ</option>
                        <option value="power">å¹‚å˜æ¢ (Power Transform)</option>
                        <option value="reciprocal">å€’æ•°å˜æ¢ (1/x)</option>
                        <option value="exponential">æŒ‡æ•°å˜æ¢ (exp(x))</option>
                        <option value="arcsinh">ååŒæ›²æ­£å¼¦å˜æ¢</option>
                        <option value="logit">Logitå˜æ¢</option>
                        <option value="zscore">Z-scoreæ ‡å‡†åŒ–</option>
                        <option value="minmax">Min-Maxå½’ä¸€åŒ–</option>
                        <option value="robust">ç¨³å¥ç¼©æ”¾ (Robust Scaling)</option>
                    </select>
                </div>
            </div>

            <div id="paramPanel" class="control-group hidden">
                <label>å˜æ¢å‚æ•°</label>
                <div class="param-inputs" id="paramInputs"></div>
            </div>

            <div class="btn-group">
                <button class="btn" id="transformBtn" disabled>æ‰§è¡Œå˜æ¢</button>
                <button class="btn" id="downloadBtn" disabled>ä¸‹è½½è½¬æ¢åæ•°æ®</button>
            </div>

            <div class="info-box">
                <h4>ğŸ’¡ å˜æ¢è¯´æ˜</h4>
                <p id="transformInfo">è¯·é€‰æ‹©å˜æ¢ç±»å‹æŸ¥çœ‹è¯¦ç»†è¯´æ˜</p>
            </div>

            <div class="stats-panel" id="statsPanel"></div>

            <div class="charts-container">
                <div class="chart-wrapper">
                    <h3>åŸå§‹æ•°æ®åˆ†å¸ƒ</h3>
                    <canvas id="originalChart" class="chart-canvas"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3>è½¬æ¢åæ•°æ®åˆ†å¸ƒ</h3>
                    <canvas id="transformedChart" class="chart-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        let csvData = [];
        let originalData = [];
        let transformedData = [];
        let headers = [];
        let originalChart, transformedChart;

        const transformInfo = {
            log: "å¯¹æ•°å˜æ¢é€‚ç”¨äºå³ååˆ†å¸ƒï¼Œè¦æ±‚æ•°æ®ä¸¥æ ¼ä¸ºæ­£ã€‚å…¬å¼: y = log(x)",
            log1p: "Log1på˜æ¢é€‚ç”¨äºåŒ…å«0çš„æ•°æ®ï¼Œå¯å¤„ç†å³ååˆ†å¸ƒã€‚å…¬å¼: y = log(1+x)",
            sqrt: "å¹³æ–¹æ ¹å˜æ¢é€‚ç”¨äºæ³Šæ¾åˆ†å¸ƒæ•°æ®ï¼Œå‡è½»å³åã€‚å…¬å¼: y = âˆšx",
            boxcox: "Box-Coxå˜æ¢è‡ªåŠ¨å¯»æ‰¾æœ€ä¼˜Î»å‚æ•°ï¼Œè¦æ±‚æ•°æ®ä¸¥æ ¼ä¸ºæ­£ã€‚å…¬å¼: y = (x^Î» - 1)/Î»",
            yeojohnson: "Yeo-Johnsonå˜æ¢æ˜¯Box-Coxçš„æ‰©å±•ï¼Œå¯å¤„ç†è´Ÿå€¼å’Œé›¶å€¼æ•°æ®",
            quantile_normal: "åˆ†ä½æ•°å˜æ¢å°†æ•°æ®æ˜ å°„åˆ°æ­£æ€åˆ†å¸ƒï¼Œä¿æŒç§©æ¬¡ä¸å˜",
            quantile_uniform: "åˆ†ä½æ•°å˜æ¢å°†æ•°æ®æ˜ å°„åˆ°å‡åŒ€åˆ†å¸ƒ[0,1]",
            power: "å¹‚å˜æ¢ä½¿ç”¨æŒ‡å®šçš„æŒ‡æ•°å¯¹æ•°æ®è¿›è¡Œå˜æ¢ã€‚å…¬å¼: y = x^p",
            reciprocal: "å€’æ•°å˜æ¢å¸¸ç”¨äºé€Ÿç‡æ•°æ®ã€‚å…¬å¼: y = 1/x",
            exponential: "æŒ‡æ•°å˜æ¢é€‚ç”¨äºå‹ç¼©æ•°æ®èŒƒå›´ã€‚å…¬å¼: y = exp(x)",
            arcsinh: "ååŒæ›²æ­£å¼¦å˜æ¢ç±»ä¼¼å¯¹æ•°ä½†å¯å¤„ç†è´Ÿå€¼ã€‚å…¬å¼: y = arcsinh(x)",
            logit: "Logitå˜æ¢å°†[0,1]åŒºé—´æ•°æ®æ˜ å°„åˆ°(-âˆ,+âˆ)ã€‚å…¬å¼: y = log(x/(1-x))",
            zscore: "Z-scoreæ ‡å‡†åŒ–ä½¿æ•°æ®å‡å€¼ä¸º0ï¼Œæ ‡å‡†å·®ä¸º1ã€‚å…¬å¼: y = (x-Î¼)/Ïƒ",
            minmax: "Min-Maxå½’ä¸€åŒ–å°†æ•°æ®ç¼©æ”¾åˆ°[0,1]ã€‚å…¬å¼: y = (x-min)/(max-min)",
            robust: "ç¨³å¥ç¼©æ”¾ä½¿ç”¨ä¸­ä½æ•°å’Œå››åˆ†ä½è·ï¼Œå¯¹å¼‚å¸¸å€¼ä¸æ•æ„Ÿ"
        };

        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        document.getElementById('columnSelect').addEventListener('change', updateOriginalChart);
        document.getElementById('transformSelect').addEventListener('change', handleTransformChange);
        document.getElementById('transformBtn').addEventListener('click', performTransform);
        document.getElementById('downloadBtn').addEventListener('click', downloadTransformedData);

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    csvData = results.data;
                    headers = results.meta.fields;
                    populateColumnSelect();
                    document.getElementById('columnSelect').disabled = false;
                    document.getElementById('transformSelect').disabled = false;
                    document.getElementById('transformBtn').disabled = false;
                }
            });
        }

        function populateColumnSelect() {
            const select = document.getElementById('columnSelect');
            select.innerHTML = '<option value="">-- é€‰æ‹©åˆ— --</option>';
            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                select.appendChild(option);
            });
        }

        function handleTransformChange() {
            const transformType = document.getElementById('transformSelect').value;
            const paramPanel = document.getElementById('paramPanel');
            const paramInputs = document.getElementById('paramInputs');
            const infoText = document.getElementById('transformInfo');
            
            infoText.textContent = transformInfo[transformType];
            paramInputs.innerHTML = '';

            if (transformType === 'power') {
                paramPanel.classList.remove('hidden');
                paramInputs.innerHTML = `
                    <div>
                        <label>æŒ‡æ•° (Power)</label>
                        <input type="number" id="powerParam" value="2" step="0.1">
                    </div>
                `;
            } else if (transformType === 'boxcox') {
                paramPanel.classList.remove('hidden');
                paramInputs.innerHTML = `
                    <div>
                        <label>Î»å‚æ•° (ç•™ç©ºè‡ªåŠ¨è®¡ç®—)</label>
                        <input type="number" id="lambdaParam" placeholder="auto" step="0.01">
                    </div>
                `;
            } else {
                paramPanel.classList.add('hidden');
            }
        }

        function updateOriginalChart() {
            const column = document.getElementById('columnSelect').value;
            if (!column) return;

            originalData = csvData.map(row => row[column]).filter(v => v !== null && !isNaN(v));
            drawHistogram(originalData, 'originalChart', 'original');
            updateStats(originalData, 'original');
        }

        function performTransform() {
            const column = document.getElementById('columnSelect').value;
            const transformType = document.getElementById('transformSelect').value;
            
            if (!column || originalData.length === 0) {
                alert('è¯·å…ˆé€‰æ‹©ç‰¹å¾åˆ—');
                return;
            }

            try {
                transformedData = applyTransform(originalData, transformType);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰NaNå€¼
                if (transformedData.some(x => isNaN(x) || !isFinite(x))) {
                    throw new Error('å˜æ¢äº§ç”Ÿäº†æ— æ•ˆå€¼(NaNæˆ–Infinity)ï¼Œè¯·æ£€æŸ¥æ•°æ®æˆ–é€‰æ‹©å…¶ä»–å˜æ¢æ–¹æ³•');
                }
                
                drawHistogram(transformedData, 'transformedChart', 'transformed');
                updateStats(transformedData, 'transformed');
                document.getElementById('downloadBtn').disabled = false;
            } catch (error) {
                alert('å˜æ¢å¤±è´¥: ' + error.message);
                console.error(error);
            }
        }

        function applyTransform(data, type) {
            switch(type) {
                case 'log':
                    if (Math.min(...data) <= 0) throw new Error('å¯¹æ•°å˜æ¢è¦æ±‚æ•°æ®ä¸¥æ ¼ä¸ºæ­£');
                    return data.map(x => Math.log(x));
                
                case 'log1p':
                    if (Math.min(...data) < 0) throw new Error('Log1på˜æ¢è¦æ±‚æ•°æ®éè´Ÿ');
                    return data.map(x => Math.log1p(x));
                
                case 'sqrt':
                    if (Math.min(...data) < 0) throw new Error('å¹³æ–¹æ ¹å˜æ¢è¦æ±‚æ•°æ®éè´Ÿ');
                    return data.map(x => Math.sqrt(x));
                
                case 'boxcox':
                    return boxCoxTransform(data);
                
                case 'yeojohnson':
                    return yeoJohnsonTransform(data);
                
                case 'quantile_normal':
                    return quantileTransform(data, 'normal');
                
                case 'quantile_uniform':
                    return quantileTransform(data, 'uniform');
                
                case 'power':
                    const power = parseFloat(document.getElementById('powerParam').value) || 2;
                    return data.map(x => Math.pow(x, power));
                
                case 'reciprocal':
                    if (data.some(x => x === 0)) throw new Error('å€’æ•°å˜æ¢ä¸èƒ½åŒ…å«0');
                    return data.map(x => 1/x);
                
                case 'exponential':
                    return data.map(x => Math.exp(x));
                
                case 'arcsinh':
                    return data.map(x => Math.asinh(x));
                
                case 'logit':
                    if (data.some(x => x <= 0 || x >= 1)) throw new Error('Logitå˜æ¢è¦æ±‚æ•°æ®åœ¨(0,1)åŒºé—´');
                    return data.map(x => Math.log(x / (1 - x)));
                
                case 'zscore':
                    return zScoreTransform(data);
                
                case 'minmax':
                    return minMaxTransform(data);
                
                case 'robust':
                    return robustScaleTransform(data);
                
                default:
                    return data;
            }
        }

        function boxCoxTransform(data) {
            const lambdaInput = document.getElementById('lambdaParam');
            let lambda = lambdaInput ? parseFloat(lambdaInput.value) : NaN;
            
            if (Math.min(...data) <= 0) throw new Error('Box-Coxå˜æ¢è¦æ±‚æ•°æ®ä¸¥æ ¼ä¸ºæ­£');
            
            if (isNaN(lambda)) {
                lambda = findOptimalLambda(data);
            }
            
            if (Math.abs(lambda) < 1e-10) {
                return data.map(x => Math.log(x));
            }
            return data.map(x => (Math.pow(x, lambda) - 1) / lambda);
        }

        function findOptimalLambda(data) {
            let bestLambda = 1;
            let bestScore = Infinity;
            
            for (let lambda = -2; lambda <= 2; lambda += 0.1) {
                let transformed;
                if (Math.abs(lambda) < 1e-10) {
                    transformed = data.map(x => Math.log(x));
                } else {
                    transformed = data.map(x => (Math.pow(x, lambda) - 1) / lambda);
                }
                const score = calculateSkewness(transformed);
                if (Math.abs(score) < Math.abs(bestScore)) {
                    bestScore = score;
                    bestLambda = lambda;
                }
            }
            return bestLambda;
        }

        function yeoJohnsonTransform(data) {
            const lambda = 1;
            return data.map(x => {
                if (x >= 0) {
                    return lambda === 0 ? Math.log(x + 1) : (Math.pow(x + 1, lambda) - 1) / lambda;
                } else {
                    return lambda === 2 ? -Math.log(-x + 1) : -(Math.pow(-x + 1, 2 - lambda) - 1) / (2 - lambda);
                }
            });
        }

        function quantileTransform(data, distribution) {
            // å‚è€ƒ scikit-learn çš„ QuantileTransformer å®ç°
            const n_samples = data.length;
            
            // 1. åˆ›å»ºæ•°æ®çš„æ’åºå‰¯æœ¬å’ŒåŸå§‹ç´¢å¼•æ˜ å°„
            const indexed_data = data.map((value, index) => ({ value, index }));
            indexed_data.sort((a, b) => a.value - b.value);
            
            // 2. è®¡ç®—æ¯ä¸ªå”¯ä¸€å€¼çš„åˆ†ä½æ•°
            // ä½¿ç”¨çº¿æ€§æ’å€¼æ–¹æ³•ï¼Œä¸ scikit-learn çš„ 'linear' æ’å€¼ä¸€è‡´
            const quantiles = new Array(n_samples);
            
            for (let i = 0; i < n_samples; i++) {
                // è®¡ç®—åˆ†ä½æ•°ï¼šä½¿ç”¨ (rank - 0.5) / n_samples
                // è¿™æ ·å¯ä»¥é¿å… 0 å’Œ 1 çš„è¾¹ç•Œé—®é¢˜
                quantiles[i] = (i + 0.5) / n_samples;
            }
            
            // 3. åˆ›å»ºæ˜ å°„ï¼šåŸå§‹å€¼ -> åˆ†ä½æ•°
            const value_to_quantile = new Map();
            for (let i = 0; i < n_samples; i++) {
                const value = indexed_data[i].value;
                if (!value_to_quantile.has(value)) {
                    // å¯¹äºç›¸åŒçš„å€¼ï¼Œå–å…¶æ‰€æœ‰ä½ç½®çš„å¹³å‡åˆ†ä½æ•°
                    const same_value_indices = [];
                    for (let j = 0; j < n_samples; j++) {
                        if (indexed_data[j].value === value) {
                            same_value_indices.push(j);
                        }
                    }
                    const avg_quantile = same_value_indices.reduce((sum, idx) => sum + quantiles[idx], 0) / same_value_indices.length;
                    value_to_quantile.set(value, avg_quantile);
                }
            }
            
            // 4. è½¬æ¢ä¸ºç›®æ ‡åˆ†å¸ƒ
            if (distribution === 'uniform') {
                // å‡åŒ€åˆ†å¸ƒï¼šç›´æ¥è¿”å›åˆ†ä½æ•° [0, 1]
                return data.map(value => value_to_quantile.get(value));
            } else {
                // æ­£æ€åˆ†å¸ƒï¼šå°†åˆ†ä½æ•°é€šè¿‡é€†æ­£æ€CDFè½¬æ¢
                return data.map(value => {
                    const quantile = value_to_quantile.get(value);
                    // ä½¿ç”¨æ›´ç²¾ç¡®çš„é€†æ­£æ€CDFï¼Œç¡®ä¿è¾¹ç•Œå¤„ç†
                    return inverseNormalCDF(quantile);
                });
            }
        }

        function inverseNormalCDF(p) {
            // ä½¿ç”¨ Peter J. Acklam çš„ç®—æ³•
            // è¿™æ˜¯ä¸€ä¸ªé«˜ç²¾åº¦çš„é€†æ­£æ€åˆ†å¸ƒç´¯ç§¯å‡½æ•°å®ç°
            
            // è¾¹ç•Œå¤„ç†ï¼šé¿å… p=0 æˆ– p=1
            if (p <= 0) return -8.2;
            if (p >= 1) return 8.2;
            
            // ç³»æ•°
            const a = [-3.969683028665376e+01, 2.209460984245205e+02,
                      -2.759285104469687e+02, 1.383577518672690e+02,
                      -3.066479806614716e+01, 2.506628277459239e+00];
            
            const b = [-5.447609879822406e+01, 1.615858368580409e+02,
                      -1.556989798598866e+02, 6.680131188771972e+01,
                      -1.328068155288572e+01];
            
            const c = [-7.784894002430293e-03, -3.223964580411365e-01,
                      -2.400758277161838e+00, -2.549732539343734e+00,
                       4.374664141464968e+00, 2.938163982698783e+00];
            
            const d = [7.784695709041462e-03, 3.224671290700398e-01,
                      2.445134137142996e+00, 3.754408661907416e+00];
            
            // å®šä¹‰åˆ†ç•Œç‚¹
            const p_low = 0.02425;
            const p_high = 1 - p_low;
            
            let q, r, z;
            
            if (p < p_low) {
                // ä¸‹å°¾éƒ¨
                q = Math.sqrt(-2 * Math.log(p));
                z = (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                    ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            } else if (p <= p_high) {
                // ä¸­å¿ƒåŒºåŸŸ
                q = p - 0.5;
                r = q * q;
                z = (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /
                    (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
            } else {
                // ä¸Šå°¾éƒ¨
                q = Math.sqrt(-2 * Math.log(1 - p));
                z = -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                     ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            }
            
            return z;
        }

        function zScoreTransform(data) {
            const mean = data.reduce((a, b) => a + b, 0) / data.length;
            const std = Math.sqrt(data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length);
            return data.map(x => (x - mean) / std);
        }

        function minMaxTransform(data) {
            const min = Math.min(...data);
            const max = Math.max(...data);
            return data.map(x => (x - min) / (max - min));
        }

        function robustScaleTransform(data) {
            const sorted = [...data].sort((a, b) => a - b);
            const q1 = sorted[Math.floor(sorted.length * 0.25)];
            const q3 = sorted[Math.floor(sorted.length * 0.75)];
            const median = sorted[Math.floor(sorted.length * 0.5)];
            const iqr = q3 - q1;
            return data.map(x => (x - median) / iqr);
        }

        function calculateSkewness(data) {
            const n = data.length;
            const mean = data.reduce((a, b) => a + b, 0) / n;
            const m3 = data.reduce((a, b) => a + Math.pow(b - mean, 3), 0) / n;
            const m2 = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
            return m3 / Math.pow(m2, 1.5);
        }

        function calculateKurtosis(data) {
            const n = data.length;
            const mean = data.reduce((a, b) => a + b, 0) / n;
            const m4 = data.reduce((a, b) => a + Math.pow(b - mean, 4), 0) / n;
            const m2 = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
            return m4 / Math.pow(m2, 2) - 3;
        }

        function drawHistogram(data, canvasId, type) {
            const ctx = document.getElementById(canvasId);
            
            if (type === 'original' && originalChart) originalChart.destroy();
            if (type === 'transformed' && transformedChart) transformedChart.destroy();
            
            const bins = 30;
            const min = Math.min(...data);
            const max = Math.max(...data);
            const binWidth = (max - min) / bins;
            
            const histogram = new Array(bins).fill(0);
            data.forEach(value => {
                const binIndex = Math.min(Math.floor((value - min) / binWidth), bins - 1);
                histogram[binIndex]++;
            });
            
            const labels = histogram.map((_, i) => (min + i * binWidth).toFixed(2));
            
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'é¢‘æ•°',
                        data: histogram,
                        backgroundColor: type === 'original' ? 'rgba(102, 126, 234, 0.7)' : 'rgba(118, 75, 162, 0.7)',
                        borderColor: type === 'original' ? 'rgba(102, 126, 234, 1)' : 'rgba(118, 75, 162, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'é¢‘æ•°' }
                        },
                        x: {
                            title: { display: true, text: 'æ•°å€¼' }
                        }
                    }
                }
            });
            
            if (type === 'original') originalChart = chart;
            else transformedChart = chart;
        }

        function updateStats(data, type) {
            const mean = data.reduce((a, b) => a + b, 0) / data.length;
            const std = Math.sqrt(data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length);
            const min = Math.min(...data);
            const max = Math.max(...data);
            const skewness = calculateSkewness(data);
            const kurtosis = calculateKurtosis(data);
            
            const statsPanel = document.getElementById('statsPanel');
            const prefix = type === 'original' ? 'åŸå§‹' : 'è½¬æ¢å';
            
            if (type === 'original') {
                statsPanel.innerHTML = '';
            }
            
            statsPanel.innerHTML += `
                <div class="stat-card">
                    <div class="label">${prefix}å‡å€¼</div>
                    <div class="value">${mean.toFixed(4)}</div>
                </div>
                <div class="stat-card">
                    <div class="label">${prefix}æ ‡å‡†å·®</div>
                    <div class="value">${std.toFixed(4)}</div>
                </div>
                <div class="stat-card">
                    <div class="label">${prefix}æœ€å°å€¼</div>
                    <div class="value">${min.toFixed(4)}</div>
                </div>
                <div class="stat-card">
                    <div class="label">${prefix}æœ€å¤§å€¼</div>
                    <div class="value">${max.toFixed(4)}</div>
                </div>
                <div class="stat-card">
                    <div class="label">${prefix}ååº¦</div>
                    <div class="value">${skewness.toFixed(4)}</div>
                </div>
                <div class="stat-card">
                    <div class="label">${prefix}å³°åº¦</div>
                    <div class="value">${kurtosis.toFixed(4)}</div>
                </div>
            `;
        }

        function downloadTransformedData() {
            const column = document.getElementById('columnSelect').value;
            const transformType = document.getElementById('transformSelect').value;
            
            // åˆ›å»ºæ–°çš„æ•°æ®é›†ï¼ŒåŒ…å«è½¬æ¢åçš„åˆ—
            const newData = csvData.map((row, i) => {
                const newRow = {...row};
                // å¦‚æœè¯¥è¡Œçš„åŸå§‹å€¼å­˜åœ¨äºtransformedDataä¸­
                if (i < transformedData.length && row[column] !== null && !isNaN(row[column])) {
                    newRow[`${column}_${transformType}`] = transformedData[i];
                } else {
                    newRow[`${column}_${transformType}`] = null;
                }
                return newRow;
            });
            
            const csv = Papa.unparse(newData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.href = url;
            link.download = 'transformed_data.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // ç«‹å³é‡Šæ”¾URLå¯¹è±¡
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }
    </script>
</body>
</html>