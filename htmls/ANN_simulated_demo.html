<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¥ç»ç½‘ç»œåˆ†ç±»å™¨</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 32px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 2px solid #e9ecef;
        }
        
        .section h2 {
            color: #495057;
            font-size: 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .control-group input, .control-group select {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .control-group small {
            color: #6c757d;
            margin-top: 5px;
            font-size: 12px;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover:not(:disabled) {
            background: #c82333;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }
        
        .chart-container h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 16px;
            text-align: center;
        }
        
        canvas {
            max-width: 100%;
            height: auto !important;
        }
        
        .status {
            background: #d1ecf1;
            border: 2px solid #bee5eb;
            color: #0c5460;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .status.training {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }
        
        .status.success {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e9ecef;
        }
        
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        .data-preview {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
        }
        
        .data-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .data-preview th, .data-preview td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        
        .data-preview th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .predict-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            margin-top: 15px;
        }
        
        .predict-result {
            margin-top: 15px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
        }
        
        .predict-result .class-label {
            font-size: 32px;
            font-weight: 700;
            color: #667eea;
            margin: 10px 0;
        }
        
        .predict-result .confidence {
            font-size: 18px;
            color: #6c757d;
        }
        
        .prob-bars {
            margin-top: 15px;
        }
        
        .prob-bar {
            margin-bottom: 10px;
        }
        
        .prob-bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
            color: #495057;
        }
        
        .prob-bar-fill {
            height: 24px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .prob-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .visualization-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§  ç¥ç»ç½‘ç»œåˆ†ç±»å™¨è®­ç»ƒå¹³å°</h1>
        <p class="subtitle">åŸºäºTensorFlow.jsçš„å…¨è¿æ¥ç¥ç»ç½‘ç»œ - äº¤äº’å¼è®­ç»ƒä¸é¢„æµ‹</p>
        
        <!-- æ•°æ®ç”Ÿæˆ -->
        <div class="section">
            <h2>ğŸ“Š æ­¥éª¤1: æ•°æ®ç”Ÿæˆ</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>æ•°æ®é›†ç±»å‹</label>
                    <select id="datasetType">
                        <option value="iris">é¸¢å°¾èŠ±åˆ†ç±» (3ç±»)</option>
                        <option value="circles">åŒå¿ƒåœ†åˆ†ç±» (2ç±»)</option>
                        <option value="spiral">èºæ—‹åˆ†ç±» (3ç±»)</option>
                        <option value="xor">XORé—®é¢˜ (2ç±»)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>è®­ç»ƒæ ·æœ¬æ•°</label>
                    <input type="number" id="trainSamples" value="300" min="50" max="2000">
                </div>
                <div class="control-group">
                    <label>æµ‹è¯•æ ·æœ¬æ•°</label>
                    <input type="number" id="testSamples" value="100" min="20" max="500">
                </div>
                <div class="control-group">
                    <label>å™ªå£°æ°´å¹³</label>
                    <input type="number" id="noiseLevel" value="0.1" min="0" max="0.5" step="0.05">
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="generateData()">ç”Ÿæˆæ•°æ®é›†</button>
                <button class="btn-secondary" onclick="exportData()" id="exportBtn" disabled>å¯¼å‡ºæ•°æ®é›† (CSV)</button>
            </div>
            <div id="dataStatus" style="display: none;" class="status"></div>
            <div id="dataPreview" class="data-preview" style="display: none;"></div>
        </div>
        
        <!-- æ¨¡å‹é…ç½® -->
        <div class="section">
            <h2>âš™ï¸ æ­¥éª¤2: æ¨¡å‹é…ç½®</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>éšè—å±‚1èŠ‚ç‚¹æ•°</label>
                    <input type="number" id="layer1Units" value="64" min="8" max="256">
                </div>
                <div class="control-group">
                    <label>éšè—å±‚2èŠ‚ç‚¹æ•°</label>
                    <input type="number" id="layer2Units" value="32" min="8" max="128">
                </div>
                <div class="control-group">
                    <label>æ¿€æ´»å‡½æ•°</label>
                    <select id="activation">
                        <option value="relu">ReLU</option>
                        <option value="tanh">Tanh</option>
                        <option value="sigmoid">Sigmoid</option>
                        <option value="elu">ELU</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Dropoutç‡</label>
                    <input type="number" id="dropout" value="0.2" min="0" max="0.5" step="0.1">
                </div>
                <div class="control-group">
                    <label>å­¦ä¹ ç‡</label>
                    <input type="number" id="learningRate" value="0.01" min="0.001" max="0.1" step="0.001">
                </div>
                <div class="control-group">
                    <label>ä¼˜åŒ–å™¨</label>
                    <select id="optimizer">
                        <option value="adam">Adam</option>
                        <option value="sgd">SGD</option>
                        <option value="rmsprop">RMSprop</option>
                    </select>
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="buildModel()" id="buildBtn" disabled>æ„å»ºæ¨¡å‹</button>
            </div>
            <div id="modelStatus" style="display: none;" class="status"></div>
        </div>
        
        <!-- è®­ç»ƒ -->
        <div class="section">
            <h2>ğŸ¯ æ­¥éª¤3: æ¨¡å‹è®­ç»ƒ</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>è®­ç»ƒè½®æ•° (Epochs)</label>
                    <input type="number" id="epochs" value="50" min="10" max="500">
                </div>
                <div class="control-group">
                    <label>æ‰¹æ¬¡å¤§å° (Batch Size)</label>
                    <input type="number" id="batchSize" value="32" min="8" max="128">
                </div>
            </div>
            <div class="button-group">
                <button class="btn-success" onclick="trainModel()" id="trainBtn" disabled>å¼€å§‹è®­ç»ƒ</button>
                <button class="btn-danger" onclick="stopTraining()" id="stopBtn" disabled>åœæ­¢è®­ç»ƒ</button>
            </div>
            <div id="trainingStatus" style="display: none;" class="status training"></div>
            <div class="metrics" id="metricsContainer" style="display: none;"></div>
            
            <div class="visualization-grid">
                <div class="chart-container" id="lossChartContainer" style="display: none;">
                    <h3>æŸå¤±æ›²çº¿</h3>
                    <canvas id="lossChart"></canvas>
                </div>
                <div class="chart-container" id="accChartContainer" style="display: none;">
                    <h3>å‡†ç¡®ç‡æ›²çº¿</h3>
                    <canvas id="accChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- é¢„æµ‹ -->
        <div class="section">
            <h2>ğŸ”® æ­¥éª¤4: æ¨¡å‹é¢„æµ‹</h2>
            <div class="predict-section">
                <p style="color: #6c757d; margin-bottom: 15px;">è¾“å…¥ç‰¹å¾å€¼è¿›è¡Œé¢„æµ‹ (æ•°å€¼èŒƒå›´: -5 åˆ° 5)</p>
                <div class="controls-grid" id="predictInputs"></div>
                <div class="button-group">
                    <button class="btn-primary" onclick="makePrediction()" id="predictBtn" disabled>æ‰§è¡Œé¢„æµ‹</button>
                    <button class="btn-secondary" onclick="randomPredict()">éšæœºæµ‹è¯•</button>
                </div>
                <div id="predictResult" class="predict-result" style="display: none;"></div>
            </div>
        </div>
        
        <!-- å¯è§†åŒ– -->
        <div class="section">
            <h2>ğŸ“ˆ æ•°æ®å¯è§†åŒ–</h2>
            <div class="visualization-grid">
                <div class="chart-container" id="dataVizContainer" style="display: none;">
                    <h3>è®­ç»ƒæ•°æ®åˆ†å¸ƒ</h3>
                    <canvas id="dataVizChart"></canvas>
                </div>
                <div class="chart-container" id="confusionContainer" style="display: none;">
                    <h3>æ··æ·†çŸ©é˜µ</h3>
                    <canvas id="confusionChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let model = null;
        let trainData = null;
        let testData = null;
        let numFeatures = 2;
        let numClasses = 2;
        let isTraining = false;
        let stopTrainingFlag = false;
        let lossChart = null;
        let accChart = null;
        
        // ç”Ÿæˆæ•°æ®é›†
        function generateData() {
            const datasetType = document.getElementById('datasetType').value;
            const trainSamples = parseInt(document.getElementById('trainSamples').value);
            const testSamples = parseInt(document.getElementById('testSamples').value);
            const noise = parseFloat(document.getElementById('noiseLevel').value);
            
            let data;
            switch(datasetType) {
                case 'iris':
                    data = generateIrisData(trainSamples, testSamples, noise);
                    numFeatures = 4;
                    numClasses = 3;
                    break;
                case 'circles':
                    data = generateCirclesData(trainSamples, testSamples, noise);
                    numFeatures = 2;
                    numClasses = 2;
                    break;
                case 'spiral':
                    data = generateSpiralData(trainSamples, testSamples, noise);
                    numFeatures = 2;
                    numClasses = 3;
                    break;
                case 'xor':
                    data = generateXORData(trainSamples, testSamples, noise);
                    numFeatures = 2;
                    numClasses = 2;
                    break;
            }
            
            trainData = data.train;
            testData = data.test;
            
            document.getElementById('dataStatus').style.display = 'block';
            document.getElementById('dataStatus').className = 'status success';
            document.getElementById('dataStatus').innerHTML = `
                âœ… æ•°æ®ç”ŸæˆæˆåŠŸï¼<br>
                è®­ç»ƒé›†: ${trainSamples} æ ·æœ¬, æµ‹è¯•é›†: ${testSamples} æ ·æœ¬<br>
                ç‰¹å¾ç»´åº¦: ${numFeatures}, ç±»åˆ«æ•°: ${numClasses}
            `;
            
            showDataPreview();
            visualizeData();
            
            document.getElementById('buildBtn').disabled = false;
            document.getElementById('exportBtn').disabled = false;
            setupPredictInputs();
        }
        
        // æ–°å¢: å¯¼å‡ºæ•°æ®é›†ä¸ºCSV
        function exportData() {
            if (!trainData || !testData) {
                alert('è¯·å…ˆç”Ÿæˆæ•°æ®é›†');
                return;
            }
            
            // å¯¼å‡ºè®­ç»ƒé›†
            const trainCsv = generateCsv(trainData.x, trainData.y, 'train');
            downloadCsv(trainCsv, 'train_data.csv');
            
            // å¯¼å‡ºæµ‹è¯•é›†
            const testCsv = generateCsv(testData.x, testData.y, 'test');
            downloadCsv(testCsv, 'test_data.csv');
            
            document.getElementById('dataStatus').innerHTML += '<br>âœ… æ•°æ®é›†å·²å¯¼å‡ºä¸ºCSVæ–‡ä»¶ï¼';
        }
        
        // ç”ŸæˆCSVå­—ç¬¦ä¸²
        function generateCsv(xData, yData, setType) {
            let csv = `Dataset,Feature1`;
            for (let i = 1; i < numFeatures; i++) {
                csv += `,Feature${i + 1}`;
            }
            csv += ',Label\n';
            
            for (let i = 0; i < xData.length; i++) {
                csv += `${setType},`;
                xData[i].forEach((val, j) => csv += `${val.toFixed(4)},`);
                csv += `${yData[i]}\n`;
            }
            
            return csv;
        }
        
        // ä¸‹è½½CSV
        function downloadCsv(csvContent, filename) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
        
        // ç”Ÿæˆé¸¢å°¾èŠ±æ•°æ®
        function generateIrisData(nTrain, nTest, noise) {
            const train = { x: [], y: [] };
            const test = { x: [], y: [] };
            
            // 3ä¸ªç±»åˆ«çš„ä¸­å¿ƒç‚¹
            const centers = [
                [5.0, 3.5, 1.5, 0.3],
                [6.0, 2.8, 4.5, 1.5],
                [6.5, 3.0, 5.5, 2.0]
            ];
            
            for (let i = 0; i < nTrain; i++) {
                const classIdx = Math.floor(Math.random() * 3);
                const features = centers[classIdx].map(c => c + (Math.random() - 0.5) * noise * 2);
                train.x.push(features);
                train.y.push(classIdx);
            }
            
            for (let i = 0; i < nTest; i++) {
                const classIdx = Math.floor(Math.random() * 3);
                const features = centers[classIdx].map(c => c + (Math.random() - 0.5) * noise * 2);
                test.x.push(features);
                test.y.push(classIdx);
            }
            
            return { train, test };
        }
        
        // ç”ŸæˆåŒå¿ƒåœ†æ•°æ®
        function generateCirclesData(nTrain, nTest, noise) {
            const train = { x: [], y: [] };
            const test = { x: [], y: [] };
            
            const generate = (n, dataset) => {
                for (let i = 0; i < n; i++) {
                    const classIdx = Math.random() > 0.5 ? 1 : 0;
                    const r = classIdx === 0 ? Math.random() * 1.5 : Math.random() * 1.5 + 2;
                    const theta = Math.random() * 2 * Math.PI;
                    const x = r * Math.cos(theta) + (Math.random() - 0.5) * noise;
                    const y = r * Math.sin(theta) + (Math.random() - 0.5) * noise;
                    dataset.x.push([x, y]);
                    dataset.y.push(classIdx);
                }
            };
            
            generate(nTrain, train);
            generate(nTest, test);
            
            return { train, test };
        }
        
        // ç”Ÿæˆèºæ—‹æ•°æ®
        function generateSpiralData(nTrain, nTest, noise) {
            const train = { x: [], y: [] };
            const test = { x: [], y: [] };
            
            const generate = (n, dataset) => {
                const samplesPerClass = Math.floor(n / 3);
                for (let c = 0; c < 3; c++) {
                    for (let i = 0; i < samplesPerClass; i++) {
                        const r = i / samplesPerClass * 3;
                        const t = i / samplesPerClass * 2 * Math.PI + c * 2 * Math.PI / 3;
                        const x = r * Math.cos(t) + (Math.random() - 0.5) * noise;
                        const y = r * Math.sin(t) + (Math.random() - 0.5) * noise;
                        dataset.x.push([x, y]);
                        dataset.y.push(c);
                    }
                }
            };
            
            generate(nTrain, train);
            generate(nTest, test);
            
            return { train, test };
        }
        
        // ç”ŸæˆXORæ•°æ®
        function generateXORData(nTrain, nTest, noise) {
            const train = { x: [], y: [] };
            const test = { x: [], y: [] };
            
            const generate = (n, dataset) => {
                for (let i = 0; i < n; i++) {
                    const x1 = Math.random() * 4 - 2;
                    const x2 = Math.random() * 4 - 2;
                    const label = (x1 > 0) !== (x2 > 0) ? 1 : 0;
                    const x1n = x1 + (Math.random() - 0.5) * noise;
                    const x2n = x2 + (Math.random() - 0.5) * noise;
                    dataset.x.push([x1n, x2n]);
                    dataset.y.push(label);
                }
            };
            
            generate(nTrain, train);
            generate(nTest, test);
            
            return { train, test };
        }
        
        // æ˜¾ç¤ºæ•°æ®é¢„è§ˆ
        function showDataPreview() {
            const preview = document.getElementById('dataPreview');
            preview.style.display = 'block';
            
            let html = '<table><thead><tr>';
            for (let i = 0; i < numFeatures; i++) {
                html += `<th>ç‰¹å¾${i + 1}</th>`;
            }
            html += '<th>ç±»åˆ«</th></tr></thead><tbody>';
            
            for (let i = 0; i < Math.min(10, trainData.x.length); i++) {
                html += '<tr>';
                for (let j = 0; j < numFeatures; j++) {
                    html += `<td>${trainData.x[i][j].toFixed(3)}</td>`;
                }
                html += `<td><strong>${trainData.y[i]}</strong></td></tr>`;
            }
            
            html += '</tbody></table>';
            preview.innerHTML = html;
        }
        
        // å¯è§†åŒ–æ•°æ®
        function visualizeData() {
            if (numFeatures !== 2) return;
            
            const container = document.getElementById('dataVizContainer');
            container.style.display = 'block';
            
            const ctx = document.getElementById('dataVizChart').getContext('2d');
            
            const colors = ['rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 206, 86)'];
            const datasets = [];
            
            for (let c = 0; c < numClasses; c++) {
                const points = trainData.x.filter((_, i) => trainData.y[i] === c)
                    .map(p => ({ x: p[0], y: p[1] }));
                
                datasets.push({
                    label: `ç±»åˆ« ${c}`,
                    data: points,
                    backgroundColor: colors[c],
                    pointRadius: 4
                });
            }
            
            new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: { title: { display: true, text: 'ç‰¹å¾1' } },
                        y: { title: { display: true, text: 'ç‰¹å¾2' } }
                    }
                }
            });
        }
        
        // æ„å»ºæ¨¡å‹
        function buildModel() {
            const layer1Units = parseInt(document.getElementById('layer1Units').value);
            const layer2Units = parseInt(document.getElementById('layer2Units').value);
            const activation = document.getElementById('activation').value;
            const dropout = parseFloat(document.getElementById('dropout').value);
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const optimizerType = document.getElementById('optimizer').value;
            
            model = tf.sequential();
            
            // è¾“å…¥å±‚ + éšè—å±‚1
            model.add(tf.layers.dense({
                units: layer1Units,
                activation: activation,
                inputShape: [numFeatures]
            }));
            model.add(tf.layers.dropout({ rate: dropout }));
            
            // éšè—å±‚2
            model.add(tf.layers.dense({
                units: layer2Units,
                activation: activation
            }));
            model.add(tf.layers.dropout({ rate: dropout }));
            
            // è¾“å‡ºå±‚
            model.add(tf.layers.dense({
                units: numClasses,
                activation: 'softmax'
            }));
            
            // é…ç½®ä¼˜åŒ–å™¨
            let optimizer;
            switch(optimizerType) {
                case 'adam':
                    optimizer = tf.train.adam(learningRate);
                    break;
                case 'sgd':
                    optimizer = tf.train.sgd(learningRate);
                    break;
                case 'rmsprop':
                    optimizer = tf.train.rmsprop(learningRate);
                    break;
            }
            
            model.compile({
                optimizer: optimizer,
                loss: 'sparseCategoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            document.getElementById('modelStatus').style.display = 'block';
            document.getElementById('modelStatus').className = 'status success';
            document.getElementById('modelStatus').innerHTML = `
                âœ… æ¨¡å‹æ„å»ºæˆåŠŸï¼<br>
                æ¶æ„: è¾“å…¥(${numFeatures}) â†’ éšè—å±‚1(${layer1Units}) â†’ éšè—å±‚2(${layer2Units}) â†’ è¾“å‡º(${numClasses})<br>
                æ€»å‚æ•°: ${model.countParams()}
            `;
            
            document.getElementById('trainBtn').disabled = false;
        }
        
        // è®­ç»ƒæ¨¡å‹
        async function trainModel() {
            if (!model || !trainData) return;
            
            isTraining = true;
            stopTrainingFlag = false;
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('buildBtn').disabled = true;
            
            const epochs = parseInt(document.getElementById('epochs').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);
            
            document.getElementById('trainingStatus').style.display = 'block';
            document.getElementById('metricsContainer').style.display = 'grid';
            document.getElementById('lossChartContainer').style.display = 'block';
            document.getElementById('accChartContainer').style.display = 'block';
            
            // å‡†å¤‡æ•°æ®
            const xsTrain = tf.tensor2d(trainData.x);
            const ysTrain = tf.tensor1d(trainData.y, 'int32');
            const xsTest = tf.tensor2d(testData.x);
            const ysTest = tf.tensor1d(testData.y, 'int32');
            
            // åˆå§‹åŒ–å›¾è¡¨
            const lossData = { train: [], test: [] };
            const accData = { train: [], test: [] };
            
            setupCharts();
            
            // è®­ç»ƒ
            for (let epoch = 0; epoch < epochs; epoch++) {
                if (stopTrainingFlag) break;
                
                const history = await model.fit(xsTrain, ysTrain, {
                    batchSize: batchSize,
                    epochs: 1,
                    validationData: [xsTest, ysTest],
                    verbose: 0
                });
                
                const trainLoss = history.history.loss[0];
                const trainAcc = history.history.acc[0];
                const testLoss = history.history.val_loss[0];
                const testAcc = history.history.val_acc[0];
                
                lossData.train.push(trainLoss);
                lossData.test.push(testLoss);
                accData.train.push(trainAcc);
                accData.test.push(testAcc);
                
                updateCharts(lossData, accData);
                
                document.getElementById('trainingStatus').innerHTML = `
                    ğŸ”„ æ­£åœ¨è®­ç»ƒ... Epoch ${epoch + 1}/${epochs}<br>
                    è®­ç»ƒæŸå¤±: ${trainLoss.toFixed(4)} | è®­ç»ƒå‡†ç¡®ç‡: ${(trainAcc * 100).toFixed(2)}%<br>
                    æµ‹è¯•æŸå¤±: ${testLoss.toFixed(4)} | æµ‹è¯•å‡†ç¡®ç‡: ${(testAcc * 100).toFixed(2)}%
                `;
                
                updateMetrics(trainLoss, trainAcc, testLoss, testAcc);
                
                await tf.nextFrame();
            }
            
            // è®­ç»ƒå®Œæˆ
            xsTrain.dispose();
            ysTrain.dispose();
            xsTest.dispose();
            ysTest.dispose();
            
            isTraining = false;
            document.getElementById('trainBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('buildBtn').disabled = false;
            document.getElementById('predictBtn').disabled = false;
            
            if (!stopTrainingFlag) {
                document.getElementById('trainingStatus').className = 'status success';
                document.getElementById('trainingStatus').innerHTML = `
                    âœ… è®­ç»ƒå®Œæˆï¼<br>
                    æœ€ç»ˆæµ‹è¯•å‡†ç¡®ç‡: ${(accData.test[accData.test.length - 1] * 100).toFixed(2)}%
                `;
                
                // æ˜¾ç¤ºæ··æ·†çŸ©é˜µ
                showConfusionMatrix();
            } else {
                document.getElementById('trainingStatus').innerHTML = 'âš ï¸ è®­ç»ƒå·²åœæ­¢';
            }
        }
        
        // åœæ­¢è®­ç»ƒ
        function stopTraining() {
            stopTrainingFlag = true;
            document.getElementById('stopBtn').disabled = true;
        }
        
        // è®¾ç½®å›¾è¡¨
        function setupCharts() {
            const lossCtx = document.getElementById('lossChart').getContext('2d');
            const accCtx = document.getElementById('accChart').getContext('2d');
            
            if (lossChart) lossChart.destroy();
            if (accChart) accChart.destroy();
            
            lossChart = new Chart(lossCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'è®­ç»ƒæŸå¤±',
                            data: [],
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'æµ‹è¯•æŸå¤±',
                            data: [],
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1.5,
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { title: { display: true, text: 'Epoch' } },
                        y: { title: { display: true, text: 'Loss' }, beginAtZero: true }
                    }
                }
            });
            
            accChart = new Chart(accCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'è®­ç»ƒå‡†ç¡®ç‡',
                            data: [],
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'æµ‹è¯•å‡†ç¡®ç‡',
                            data: [],
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1.5,
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { title: { display: true, text: 'Epoch' } },
                        y: { title: { display: true, text: 'Accuracy' }, beginAtZero: true, max: 1 }
                    }
                }
            });
        }
        
        // æ›´æ–°å›¾è¡¨
        function updateCharts(lossData, accData) {
            const epochs = lossData.train.length;
            const labels = Array.from({ length: epochs }, (_, i) => i + 1);
            
            lossChart.data.labels = labels;
            lossChart.data.datasets[0].data = lossData.train;
            lossChart.data.datasets[1].data = lossData.test;
            lossChart.update('none');
            
            accChart.data.labels = labels;
            accChart.data.datasets[0].data = accData.train;
            accChart.data.datasets[1].data = accData.test;
            accChart.update('none');
        }
        
        // æ›´æ–°æŒ‡æ ‡
        function updateMetrics(trainLoss, trainAcc, testLoss, testAcc) {
            document.getElementById('metricsContainer').innerHTML = `
                <div class="metric-card">
                    <div class="metric-label">è®­ç»ƒæŸå¤±</div>
                    <div class="metric-value">${trainLoss.toFixed(4)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">è®­ç»ƒå‡†ç¡®ç‡</div>
                    <div class="metric-value">${(trainAcc * 100).toFixed(2)}%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">æµ‹è¯•æŸå¤±</div>
                    <div class="metric-value">${testLoss.toFixed(4)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">æµ‹è¯•å‡†ç¡®ç‡</div>
                    <div class="metric-value">${(testAcc * 100).toFixed(2)}%</div>
                </div>
            `;
        }
        
        // è®¾ç½®é¢„æµ‹è¾“å…¥æ¡†
        function setupPredictInputs() {
            const container = document.getElementById('predictInputs');
            let html = '';
            
            const featureNames = numFeatures === 4 
                ? ['èŠ±è¼é•¿åº¦', 'èŠ±è¼å®½åº¦', 'èŠ±ç“£é•¿åº¦', 'èŠ±ç“£å®½åº¦']
                : Array.from({ length: numFeatures }, (_, i) => `ç‰¹å¾${i + 1}`);
            
            for (let i = 0; i < numFeatures; i++) {
                html += `
                    <div class="control-group">
                        <label>${featureNames[i]}</label>
                        <input type="number" id="feature${i}" value="0" step="0.1">
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        // æ‰§è¡Œé¢„æµ‹
        async function makePrediction() {
            if (!model) return;
            
            const features = [];
            for (let i = 0; i < numFeatures; i++) {
                features.push(parseFloat(document.getElementById(`feature${i}`).value));
            }
            
            const input = tf.tensor2d([features]);
            const prediction = model.predict(input);
            const probabilities = await prediction.data();
            
            const predictedClass = probabilities.indexOf(Math.max(...probabilities));
            const confidence = probabilities[predictedClass];
            
            displayPrediction(predictedClass, confidence, probabilities);
            
            input.dispose();
            prediction.dispose();
        }
        
        // éšæœºæµ‹è¯•
        function randomPredict() {
            if (!testData) return;
            
            const idx = Math.floor(Math.random() * testData.x.length);
            const sample = testData.x[idx];
            
            for (let i = 0; i < numFeatures; i++) {
                document.getElementById(`feature${i}`).value = sample[i].toFixed(3);
            }
            
            makePrediction();
        }
        
        // æ˜¾ç¤ºé¢„æµ‹ç»“æœ
        function displayPrediction(classIdx, confidence, probabilities) {
            const result = document.getElementById('predictResult');
            result.style.display = 'block';
            
            let html = `
                <div class="class-label">ç±»åˆ«: ${classIdx}</div>
                <div class="confidence">ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(2)}%</div>
                <div class="prob-bars">
            `;
            
            for (let i = 0; i < numClasses; i++) {
                const prob = probabilities[i];
                html += `
                    <div class="prob-bar">
                        <div class="prob-bar-label">
                            <span>ç±»åˆ« ${i}</span>
                            <span>${(prob * 100).toFixed(2)}%</span>
                        </div>
                        <div class="prob-bar-fill">
                            <div class="prob-bar-inner" style="width: ${prob * 100}%">
                                ${prob > 0.1 ? (prob * 100).toFixed(1) + '%' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            result.innerHTML = html;
        }
        
        // æ˜¾ç¤ºæ··æ·†çŸ©é˜µ
        async function showConfusionMatrix() {
            if (!model || !testData) return;
            
            const container = document.getElementById('confusionContainer');
            container.style.display = 'block';
            
            const xsTest = tf.tensor2d(testData.x);
            const predictions = model.predict(xsTest);
            const predictedClasses = predictions.argMax(-1);
            const predArray = await predictedClasses.data();
            
            // è®¡ç®—æ··æ·†çŸ©é˜µ
            const matrix = Array(numClasses).fill(0).map(() => Array(numClasses).fill(0));
            
            for (let i = 0; i < testData.y.length; i++) {
                const trueClass = testData.y[i];
                const predClass = predArray[i];
                matrix[trueClass][predClass]++;
            }
            
            // ç»˜åˆ¶çƒ­åŠ›å›¾
            const ctx = document.getElementById('confusionChart').getContext('2d');
            const canvas = document.getElementById('confusionChart');
            canvas.width = 400;
            canvas.height = 400;
            
            const cellSize = 400 / numClasses;
            const maxVal = Math.max(...matrix.flat());
            
            ctx.clearRect(0, 0, 400, 400);
            
            for (let i = 0; i < numClasses; i++) {
                for (let j = 0; j < numClasses; j++) {
                    const value = matrix[i][j];
                    const intensity = value / maxVal;
                    
                    ctx.fillStyle = `rgba(102, 126, 234, ${intensity})`;
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    
                    ctx.fillStyle = intensity > 0.5 ? '#fff' : '#333';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(value, j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
                }
            }
            
            // æ·»åŠ æ ‡ç­¾
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            for (let i = 0; i < numClasses; i++) {
                ctx.fillText(`é¢„æµ‹: ${i}`, i * cellSize + cellSize / 2, 400 - 10);
                ctx.save();
                ctx.translate(10, i * cellSize + cellSize / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(`çœŸå®: ${i}`, 0, 0);
                ctx.restore();
            }
            
            xsTest.dispose();
            predictions.dispose();
            predictedClasses.dispose();
        }
    </script>
</body>
</html>