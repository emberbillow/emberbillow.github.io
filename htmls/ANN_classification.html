<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”¨æˆ·æ•°æ®ç¥ç»ç½‘ç»œåˆ†ç±»å™¨</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 32px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 2px solid #e9ecef;
        }
        
        .section h2 {
            color: #495057;
            font-size: 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .control-group input, .control-group select, .control-group textarea {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .control-group input:focus, .control-group select:focus, .control-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .control-group small {
            color: #6c757d;
            margin-top: 5px;
            font-size: 12px;
        }
        
        .file-upload {
            border: 2px dashed #dee2e6;
            padding: 20px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        
        .file-upload:hover {
            border-color: #667eea;
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover:not(:disabled) {
            background: #c82333;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }
        
        .chart-container h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 16px;
            text-align: center;
        }
        
        canvas {
            max-width: 100%;
            height: auto !important;
        }
        
        .status {
            background: #d1ecf1;
            border: 2px solid #bee5eb;
            color: #0c5460;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .status.training {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }
        
        .status.success {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e9ecef;
        }
        
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        .data-preview {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
        }
        
        .data-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .data-preview th, .data-preview td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        
        .data-preview th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .variable-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }
        
        .var-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .var-group h4 {
            margin-bottom: 10px;
            color: #495057;
        }
        
        .predict-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            margin-top: 15px;
        }
        
        .predict-result {
            margin-top: 15px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
        }
        
        .predict-result .class-label {
            font-size: 32px;
            font-weight: 700;
            color: #667eea;
            margin: 10px 0;
        }
        
        .predict-result .confidence {
            font-size: 18px;
            color: #6c757d;
        }
        
        .prob-bars {
            margin-top: 15px;
        }
        
        .prob-bar {
            margin-bottom: 10px;
        }
        
        .prob-bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
            color: #495057;
        }
        
        .prob-bar-fill {
            height: 24px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .prob-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
        
        .batch-results {
            margin-top: 15px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .batch-results table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .batch-results th, .batch-results td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        
        .batch-results th {
            background: #f8f9fa;
            font-weight: 600;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .visualization-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script>
        // å°è¯•ä½¿ç”¨WebGLåŠ é€Ÿè®­ç»ƒï¼ˆå¦‚æœæµè§ˆå™¨æ”¯æŒï¼‰
        if (typeof tf !== 'undefined') {
            tf.setBackend('webgl').then(() => console.log('Using WebGL backend for faster training'));
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>ğŸ§  ç”¨æˆ·æ•°æ®ç¥ç»ç½‘ç»œåˆ†ç±»å™¨</h1>
        <p class="subtitle">åŸºäºTensorFlow.jsçš„å…¨è¿æ¥ç¥ç»ç½‘ç»œ - ä¸Šä¼ CSVæ•°æ®è¿›è¡Œè®­ç»ƒä¸é¢„æµ‹</p>
        
        <!-- æ•°æ®ä¸Šä¼  -->
        <div class="section">
            <h2>ğŸ“Š æ­¥éª¤1: ä¸Šä¼ æ•°æ®</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>è®­ç»ƒæ•°æ®CSV (å¸¦æ ‡ç­¾)</label>
                    <div class="file-upload" onclick="document.getElementById('trainFile').click()">
                        <input type="file" id="trainFile" accept=".csv" onchange="loadTrainCSV(event)">
                        <p>ç‚¹å‡»ä¸Šä¼ è®­ç»ƒCSV</p>
                        <small>åŒ…å«è¡¨å¤´ï¼Œæ¯åˆ—ä¸€ä¸ªå±æ€§ï¼Œæœ€åä¸€åˆ—ä¸ºæ ‡ç­¾</small>
                    </div>
                </div>
                <div class="control-group">
                    <label>é¢„æµ‹æ•°æ®CSV (æ— æ ‡ç­¾)</label>
                    <div class="file-upload" onclick="document.getElementById('predictFile').click()">
                        <input type="file" id="predictFile" accept=".csv" onchange="loadPredictCSV(event)">
                        <p>ç‚¹å‡»ä¸Šä¼ é¢„æµ‹CSV</p>
                        <small>åŒ…å«è¡¨å¤´ï¼Œä¸è®­ç»ƒæ•°æ®ç‰¹å¾åˆ—ä¸€è‡´</small>
                    </div>
                </div>
            </div>
            <div id="dataStatus" style="display: none;" class="status"></div>
            <div id="dataPreview" class="data-preview" style="display: none;"></div>
        </div>
        
        <!-- å˜é‡é€‰æ‹© -->
        <div class="section">
            <h2>ğŸ”§ æ­¥éª¤2: é€‰æ‹©å˜é‡</h2>
            <div id="variableSelection" class="variable-selection" style="display: none;"></div>
            <div class="button-group">
                <button class="btn-primary" onclick="selectVariables()" id="selectBtn" disabled>ç¡®è®¤é€‰æ‹©</button>
            </div>
            <div id="varStatus" style="display: none;" class="status"></div>
        </div>
        
        <!-- æ¨¡å‹é…ç½® -->
        <div class="section">
            <h2>âš™ï¸ æ­¥éª¤3: æ¨¡å‹é…ç½®</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>éšè—å±‚èŠ‚ç‚¹æ•° (JSONæ•°ç»„)<br><small>ä¾‹: [64, 32, 16] (1-5å±‚)</small></label>
                    <input type="text" id="hiddenLayers" value="[64, 32]" placeholder="[64, 32]">
                </div>
                <div class="control-group">
                    <label>æ¿€æ´»å‡½æ•°</label>
                    <select id="activation">
                        <option value="relu">ReLU</option>
                        <option value="tanh">Tanh</option>
                        <option value="sigmoid">Sigmoid</option>
                        <option value="elu">ELU</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Dropoutç‡</label>
                    <input type="number" id="dropout" value="0.2" min="0" max="0.5" step="0.1">
                </div>
                <div class="control-group">
                    <label>å­¦ä¹ ç‡</label>
                    <input type="number" id="learningRate" value="0.01" min="0.001" max="0.1" step="0.001">
                </div>
                <div class="control-group">
                    <label>ä¼˜åŒ–å™¨</label>
                    <select id="optimizer">
                        <option value="adam">Adam</option>
                        <option value="sgd">SGD</option>
                        <option value="rmsprop">RMSprop</option>
                    </select>
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="buildModel()" id="buildBtn" disabled>æ„å»ºæ¨¡å‹</button>
            </div>
            <div id="modelStatus" style="display: none;" class="status"></div>
        </div>
        
        <!-- è®­ç»ƒ -->
        <div class="section">
            <h2>ğŸ¯ æ­¥éª¤4: æ¨¡å‹è®­ç»ƒ</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>è®­ç»ƒè½®æ•° (Epochs)</label>
                    <input type="number" id="epochs" value="50" min="10" max="500">
                </div>
                <div class="control-group">
                    <label>æ‰¹æ¬¡å¤§å° (Batch Size)</label>
                    <input type="number" id="batchSize" value="32" min="8" max="128">
                </div>
                <div class="control-group">
                    <label>éªŒè¯é›†æ¯”ä¾‹</label>
                    <input type="number" id="validationSplit" value="0.2" min="0.1" max="0.3" step="0.05">
                </div>
            </div>
            <div class="button-group">
                <button class="btn-success" onclick="trainModel()" id="trainBtn" disabled>å¼€å§‹è®­ç»ƒ</button>
                <button class="btn-danger" onclick="stopTraining()" id="stopBtn" disabled>åœæ­¢è®­ç»ƒ</button>
            </div>
            <div id="trainingStatus" style="display: none;" class="status training"></div>
            <div class="metrics" id="metricsContainer" style="display: none;"></div>
            
            <div class="visualization-grid">
                <div class="chart-container" id="lossChartContainer" style="display: none;">
                    <h3>æŸå¤±æ›²çº¿</h3>
                    <canvas id="lossChart"></canvas>
                </div>
                <div class="chart-container" id="accChartContainer" style="display: none;">
                    <h3>å‡†ç¡®ç‡æ›²çº¿</h3>
                    <canvas id="accChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- é¢„æµ‹ -->
        <div class="section">
            <h2>ğŸ”® æ­¥éª¤5: æ‰¹é‡é¢„æµ‹</h2>
            <div class="predict-section">
                <p style="color: #6c757d; margin-bottom: 15px;">ä½¿ç”¨ä¸Šä¼ çš„é¢„æµ‹CSVè¿›è¡Œæ‰¹é‡é¢„æµ‹</p>
                <div class="button-group">
                    <button class="btn-primary" onclick="makeBatchPrediction()" id="predictBtn" disabled>æ‰§è¡Œæ‰¹é‡é¢„æµ‹</button>
                    <button class="btn-secondary" onclick="downloadPredictions()">ä¸‹è½½ç»“æœCSV</button>
                </div>
                <div id="predictResult" class="predict-result" style="display: none;"></div>
                <div id="batchResults" class="batch-results" style="display: none;"></div>
            </div>
        </div>
        
        <!-- å¯è§†åŒ– -->
        <div class="section">
            <h2>ğŸ“ˆ æ•°æ®å¯è§†åŒ–</h2>
            <div class="visualization-grid">
                <div class="chart-container" id="dataVizContainer" style="display: none;">
                    <h3>è®­ç»ƒæ•°æ®åˆ†å¸ƒ (å‰2ç‰¹å¾)</h3>
                    <canvas id="dataVizChart"></canvas>
                </div>
                <div class="chart-container" id="confusionContainer" style="display: none;">
                    <h3>æ··æ·†çŸ©é˜µ</h3>
                    <canvas id="confusionChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let model = null;
        let trainData = null;
        let predictData = null;
        let selectedFeatures = [];
        let selectedLabel = null;
        let numFeatures = 0;
        let numClasses = 0;
        let isTraining = false;
        let stopTrainingFlag = false;
        let lossChart = null;
        let accChart = null;
        let trainCsvData = null;
        let predictCsvData = null;
        let predictionResults = [];
        
        // åŠ è½½è®­ç»ƒCSV
        function loadTrainCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            Papa.parse(file, {
                header: true,
                complete: function(results) {
                    trainCsvData = results.data.filter(row => Object.values(row).some(val => val !== '')); // è¿‡æ»¤ç©ºè¡Œ
                    document.getElementById('dataStatus').style.display = 'block';
                    document.getElementById('dataStatus').className = 'status success';
                    document.getElementById('dataStatus').innerHTML = `âœ… è®­ç»ƒCSVåŠ è½½æˆåŠŸï¼${trainCsvData.length} è¡Œæ•°æ®ï¼Œ${Object.keys(trainCsvData[0]).length} åˆ—ã€‚`;
                    showDataPreview(trainCsvData);
                    document.getElementById('selectBtn').disabled = false;
                    setupVariableSelection(Object.keys(trainCsvData[0]));
                },
                error: function(error) {
                    showStatus('dataStatus', 'error', `âŒ CSVåŠ è½½å¤±è´¥: ${error}`);
                }
            });
        }
        
        // åŠ è½½é¢„æµ‹CSV
        function loadPredictCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            Papa.parse(file, {
                header: true,
                complete: function(results) {
                    predictCsvData = results.data.filter(row => Object.values(row).some(val => val !== '')); // è¿‡æ»¤ç©ºè¡Œ
                    document.getElementById('dataStatus').style.display = 'block';
                    document.getElementById('dataStatus').className = 'status success';
                    document.getElementById('dataStatus').innerHTML += `<br>âœ… é¢„æµ‹CSVåŠ è½½æˆåŠŸï¼${predictCsvData.length} è¡Œæ•°æ®ã€‚`;
                    showDataPreview(predictCsvData, 'predict');
                },
                error: function(error) {
                    showStatus('dataStatus', 'error', `âŒ é¢„æµ‹CSVåŠ è½½å¤±è´¥: ${error}`);
                }
            });
        }
        
        // æ˜¾ç¤ºæ•°æ®é¢„è§ˆ
        function showDataPreview(data, type = 'train') {
            const preview = document.getElementById('dataPreview');
            preview.style.display = 'block';
            
            const keys = Object.keys(data[0]);
            let html = '<table><thead><tr>';
            keys.slice(0, 5).forEach(key => html += `<th>${key}</th>`); // æ˜¾ç¤ºå‰5åˆ—
            html += '</tr></thead><tbody>';
            
            data.slice(0, 10).forEach(row => {
                html += '<tr>';
                keys.slice(0, 5).forEach(key => html += `<td>${row[key] || ''}</td>`);
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            preview.innerHTML = `<h4>${type === 'train' ? 'è®­ç»ƒæ•°æ®' : 'é¢„æµ‹æ•°æ®'}é¢„è§ˆ</h4>${html}`;
        }
        
        // è®¾ç½®å˜é‡é€‰æ‹©
        function setupVariableSelection(columns) {
            const container = document.getElementById('variableSelection');
            container.style.display = 'block';
            
            let html = `
                <div class="var-group">
                    <h4>é¢„æµ‹å˜é‡ (ç‰¹å¾ï¼Œå¤šé€‰)</h4>
                    <select multiple id="featuresSelect" size="${Math.min(10, columns.length)}">
            `;
            columns.forEach(col => html += `<option value="${col}">${col}</option>`);
            html += `
                    </select>
                    <small>æŒ‰Ctrl/Cmdå¤šé€‰</small>
                </div>
                <div class="var-group">
                    <h4>å“åº”å˜é‡ (æ ‡ç­¾ï¼Œå•é€‰)</h4>
                    <select id="labelSelect">
            `;
            columns.forEach(col => html += `<option value="${col}">${col}</option>`);
            html += '</select></div>';
            
            container.innerHTML = html;
        }
        
        // ç¡®è®¤å˜é‡é€‰æ‹©
        function selectVariables() {
            const featuresSelect = document.getElementById('featuresSelect');
            selectedFeatures = Array.from(featuresSelect.selectedOptions).map(opt => opt.value);
            selectedLabel = document.getElementById('labelSelect').value;
            
            if (selectedFeatures.length === 0 || !selectedLabel) {
                showStatus('varStatus', 'error', 'âŒ è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªç‰¹å¾å’Œä¸€ä¸ªæ ‡ç­¾åˆ—');
                return;
            }
            
            if (!selectedFeatures.includes(selectedLabel)) {
                numFeatures = selectedFeatures.length;
                // æå–æ•°æ®
                trainData = {
                    x: trainCsvData.map(row => selectedFeatures.map(col => parseFloat(row[col]) || 0)),
                    y: trainCsvData.map(row => parseInt(row[selectedLabel]) || 0)
                };
                // ç¡®å®šç±»åˆ«æ•°
                const labelsSet = [...new Set(trainData.y)];
                numClasses = labelsSet.length;
                
                showStatus('varStatus', 'success', `âœ… å˜é‡é€‰æ‹©æˆåŠŸï¼ç‰¹å¾: ${numFeatures}ä¸ªï¼Œç±»åˆ«: ${numClasses}ä¸ª`);
                document.getElementById('buildBtn').disabled = false;
                visualizeData();
            } else {
                showStatus('varStatus', 'error', 'âŒ æ ‡ç­¾åˆ—ä¸èƒ½ä½œä¸ºç‰¹å¾');
            }
        }
        
        // æ˜¾ç¤ºçŠ¶æ€
        function showStatus(id, type, msg) {
            const elem = document.getElementById(id);
            elem.style.display = 'block';
            elem.className = `status ${type}`;
            elem.innerHTML = msg;
        }
        
        // å¯è§†åŒ–æ•°æ® (å‰2ç‰¹å¾)
        function visualizeData() {
            if (numFeatures < 2) return;
            
            const container = document.getElementById('dataVizContainer');
            container.style.display = 'block';
            
            const ctx = document.getElementById('dataVizChart').getContext('2d');
            const colors = ['rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 206, 86)', 'rgb(75, 192, 192)'];
            const datasets = [];
            
            for (let c = 0; c < numClasses; c++) {
                const points = trainData.x.filter((_, i) => trainData.y[i] === c)
                    .map((p, idx) => ({ x: p[0], y: p[1] })); // å‰2ç‰¹å¾
                
                datasets.push({
                    label: `ç±»åˆ« ${c}`,
                    data: points,
                    backgroundColor: colors[c % colors.length],
                    pointRadius: 4
                });
            }
            
            new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { title: { display: true, text: selectedFeatures[0] } },
                        y: { title: { display: true, text: selectedFeatures[1] } }
                    }
                }
            });
        }
        
        // æ„å»ºæ¨¡å‹
        function buildModel() {
            try {
                const hiddenLayersStr = document.getElementById('hiddenLayers').value.trim();
                let hiddenLayers = [64, 32];
                if (hiddenLayersStr) {
                    hiddenLayers = JSON.parse(hiddenLayersStr);
                    if (!Array.isArray(hiddenLayers) || hiddenLayers.length === 0 || hiddenLayers.length > 5) {
                        throw new Error('æ— æ•ˆæ•°ç»„ï¼šå¿…é¡»æ˜¯1-5ä¸ªæ­£æ•´æ•°');
                    }
                    hiddenLayers = hiddenLayers.map(u => Math.max(8, Math.min(256, parseInt(u))));
                }
                
                const activation = document.getElementById('activation').value;
                const dropout = parseFloat(document.getElementById('dropout').value);
                const learningRate = parseFloat(document.getElementById('learningRate').value);
                const optimizerType = document.getElementById('optimizer').value;
                
                model = tf.sequential();
                
                model.add(tf.layers.dense({
                    units: hiddenLayers[0],
                    activation: activation,
                    inputShape: [numFeatures]
                }));
                model.add(tf.layers.dropout({ rate: dropout }));
                
                for (let i = 1; i < hiddenLayers.length; i++) {
                    model.add(tf.layers.dense({
                        units: hiddenLayers[i],
                        activation: activation
                    }));
                    model.add(tf.layers.dropout({ rate: dropout }));
                }
                
                model.add(tf.layers.dense({
                    units: numClasses,
                    activation: 'softmax'
                }));
                
                let optimizer;
                switch(optimizerType) {
                    case 'adam': optimizer = tf.train.adam(learningRate); break;
                    case 'sgd': optimizer = tf.train.sgd(learningRate); break;
                    case 'rmsprop': optimizer = tf.train.rmsprop(learningRate); break;
                }
                
                model.compile({
                    optimizer: optimizer,
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                
                model.summary();
                
                showStatus('modelStatus', 'success', `âœ… æ¨¡å‹æ„å»ºæˆåŠŸï¼éšè—å±‚: [${hiddenLayers.join(' â†’ ')}] | æ€»å‚æ•°: ${model.countParams()}`);
                document.getElementById('trainBtn').disabled = false;
            } catch (error) {
                showStatus('modelStatus', 'error', `âŒ æ„å»ºå¤±è´¥: ${error.message}`);
                console.error(error);
            }
        }
        
        // è®­ç»ƒæ¨¡å‹
        async function trainModel() {
            if (!model || !trainData) {
                alert('è¯·ä¸Šä¼ æ•°æ®ã€é€‰æ‹©å˜é‡å¹¶æ„å»ºæ¨¡å‹');
                return;
            }
            
            try {
                isTraining = true;
                stopTrainingFlag = false;
                document.getElementById('trainBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('buildBtn').disabled = true;
                
                const epochs = parseInt(document.getElementById('epochs').value);
                const batchSize = parseInt(document.getElementById('batchSize').value);
                const validationSplit = parseFloat(document.getElementById('validationSplit').value);
                
                showStatus('trainingStatus', 'training', 'ğŸ”„ åˆå§‹åŒ–è®­ç»ƒ...');
                document.getElementById('metricsContainer').style.display = 'grid';
                document.getElementById('lossChartContainer').style.display = 'block';
                document.getElementById('accChartContainer').style.display = 'block';
                
                const xs = tf.tensor2d(trainData.x);
                const ysLabels = tf.tensor1d(trainData.y, 'int32');
                const ys = tf.oneHot(ysLabels, numClasses);
                
                const lossData = { train: [], val: [] };
                const accData = { train: [], val: [] };
                
                setupCharts();
                
                for (let epoch = 0; epoch < epochs; epoch++) {
                    if (stopTrainingFlag) break;
                    
                    const history = await model.fit(xs, ys, {
                        batchSize: batchSize,
                        epochs: 1,
                        validationSplit: validationSplit,
                        verbose: 0
                    });
                    
                    const trainLoss = history.history.loss[0];
                    const trainAcc = history.history.acc[0];
                    const valLoss = history.history.val_loss[0];
                    const valAcc = history.history.val_acc[0];
                    
                    lossData.train.push(trainLoss);
                    lossData.val.push(valLoss);
                    accData.train.push(trainAcc);
                    accData.val.push(valAcc);
                    
                    updateCharts(lossData, accData);
                    updateMetrics(trainLoss, trainAcc, valLoss, valAcc);
                    
                    const progress = ((epoch + 1) / epochs * 100).toFixed(1);
                    showStatus('trainingStatus', 'training', `
                        ğŸ”„ æ­£åœ¨è®­ç»ƒ... Epoch ${epoch + 1}/${epochs} (${progress}%)<br>
                        è®­ç»ƒæŸå¤±: ${trainLoss.toFixed(4)} | è®­ç»ƒå‡†ç¡®ç‡: ${(trainAcc * 100).toFixed(2)}%<br>
                        éªŒè¯æŸå¤±: ${valLoss.toFixed(4)} | éªŒè¯å‡†ç¡®ç‡: ${(valAcc * 100).toFixed(2)}%
                    `);
                    
                    if ((epoch + 1) % 5 === 0 || epoch === epochs - 1) {
                        await new Promise(resolve => requestAnimationFrame(resolve));
                    } else {
                        await tf.nextFrame();
                    }
                }
                
                xs.dispose();
                ys.dispose();
                ysLabels.dispose();
                
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('buildBtn').disabled = false;
                document.getElementById('predictBtn').disabled = false;
                
                if (!stopTrainingFlag) {
                    showStatus('trainingStatus', 'success', `âœ… è®­ç»ƒå®Œæˆï¼æœ€ç»ˆéªŒè¯å‡†ç¡®ç‡: ${(accData.val[accData.val.length - 1] * 100).toFixed(2)}%`);
                    showConfusionMatrix();
                } else {
                    showStatus('trainingStatus', 'training', 'âš ï¸ è®­ç»ƒå·²åœæ­¢');
                }
            } catch (error) {
                console.error('è®­ç»ƒé”™è¯¯:', error);
                showStatus('trainingStatus', 'error', `âŒ è®­ç»ƒå¤±è´¥: ${error.message}`);
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        function stopTraining() {
            stopTrainingFlag = true;
            document.getElementById('stopBtn').disabled = true;
        }
        
        function setupCharts() {
            const lossCtx = document.getElementById('lossChart').getContext('2d');
            const accCtx = document.getElementById('accChart').getContext('2d');
            
            if (lossChart) lossChart.destroy();
            if (accChart) accChart.destroy();
            
            lossChart = new Chart(lossCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'è®­ç»ƒæŸå¤±', data: [], borderColor: 'rgb(255, 99, 132)', backgroundColor: 'rgba(255, 99, 132, 0.1)', tension: 0.4 },
                        { label: 'éªŒè¯æŸå¤±', data: [], borderColor: 'rgb(54, 162, 235)', backgroundColor: 'rgba(54, 162, 235, 0.1)', tension: 0.4 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1.5,
                    plugins: { legend: { display: true } },
                    scales: { x: { title: { display: true, text: 'Epoch' } }, y: { title: { display: true, text: 'Loss' }, beginAtZero: true } }
                }
            });
            
            accChart = new Chart(accCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'è®­ç»ƒå‡†ç¡®ç‡', data: [], borderColor: 'rgb(75, 192, 192)', backgroundColor: 'rgba(75, 192, 192, 0.1)', tension: 0.4 },
                        { label: 'éªŒè¯å‡†ç¡®ç‡', data: [], borderColor: 'rgb(153, 102, 255)', backgroundColor: 'rgba(153, 102, 255, 0.1)', tension: 0.4 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1.5,
                    plugins: { legend: { display: true } },
                    scales: { x: { title: { display: true, text: 'Epoch' } }, y: { title: { display: true, text: 'Accuracy' }, beginAtZero: true, max: 1 } }
                }
            });
        }
        
        function updateCharts(lossData, accData) {
            const epochs = lossData.train.length;
            const labels = Array.from({ length: epochs }, (_, i) => i + 1);
            
            lossChart.data.labels = labels;
            lossChart.data.datasets[0].data = lossData.train;
            lossChart.data.datasets[1].data = lossData.val;
            lossChart.update('none');
            
            accChart.data.labels = labels;
            accChart.data.datasets[0].data = accData.train;
            accChart.data.datasets[1].data = accData.val;
            accChart.update('none');
        }
        
        function updateMetrics(trainLoss, trainAcc, valLoss, valAcc) {
            document.getElementById('metricsContainer').innerHTML = `
                <div class="metric-card"><div class="metric-label">è®­ç»ƒæŸå¤±</div><div class="metric-value">${trainLoss.toFixed(4)}</div></div>
                <div class="metric-card"><div class="metric-label">è®­ç»ƒå‡†ç¡®ç‡</div><div class="metric-value">${(trainAcc * 100).toFixed(2)}%</div></div>
                <div class="metric-card"><div class="metric-label">éªŒè¯æŸå¤±</div><div class="metric-value">${valLoss.toFixed(4)}</div></div>
                <div class="metric-card"><div class="metric-label">éªŒè¯å‡†ç¡®ç‡</div><div class="metric-value">${(valAcc * 100).toFixed(2)}%</div></div>
            `;
        }
        
        // æ‰¹é‡é¢„æµ‹
        async function makeBatchPrediction() {
            if (!model || !predictCsvData || selectedFeatures.length === 0) {
                alert('è¯·ä¸Šä¼ é¢„æµ‹æ•°æ®ã€é€‰æ‹©å˜é‡ã€è®­ç»ƒæ¨¡å‹');
                return;
            }
            
            try {
                const xsPredict = tf.tensor2d(predictCsvData.map(row => selectedFeatures.map(col => parseFloat(row[col]) || 0)));
                const predictions = model.predict(xsPredict);
                const probs = await predictions.data();
                const predClasses = [];
                const confidences = [];
                
                for (let i = 0; i < predictCsvData.length; i++) {
                    const start = i * numClasses;
                    const rowProbs = probs.slice(start, start + numClasses);
                    const predClass = rowProbs.indexOf(Math.max(...rowProbs));
                    const confidence = rowProbs[predClass];
                    predClasses.push(predClass);
                    confidences.push(confidence);
                    
                    // å­˜å‚¨ç»“æœ
                    predictCsvData[i]['é¢„æµ‹ç±»åˆ«'] = predClass;
                    predictCsvData[i]['ç½®ä¿¡åº¦'] = confidence.toFixed(4);
                }
                
                predictionResults = predictCsvData;
                showStatus('predictResult', 'success', `âœ… æ‰¹é‡é¢„æµ‹å®Œæˆï¼${predictCsvData.length} è¡Œç»“æœã€‚`);
                displayBatchResults();
                
                xsPredict.dispose();
                predictions.dispose();
            } catch (error) {
                showStatus('predictResult', 'error', `âŒ é¢„æµ‹å¤±è´¥: ${error.message}`);
            }
        }
        
        // æ˜¾ç¤ºæ‰¹é‡ç»“æœ
        function displayBatchResults() {
            const container = document.getElementById('batchResults');
            container.style.display = 'block';
            
            const keys = Object.keys(predictionResults[0]).slice(0, 5); // å‰5åˆ— + é¢„æµ‹
            keys.push('é¢„æµ‹ç±»åˆ«', 'ç½®ä¿¡åº¦');
            
            let html = '<table><thead><tr>';
            keys.forEach(key => html += `<th>${key}</th>`);
            html += '</tr></thead><tbody>';
            
            predictionResults.slice(0, 20).forEach(row => { // æ˜¾ç¤ºå‰20è¡Œ
                html += '<tr>';
                keys.slice(0, -2).forEach(key => html += `<td>${row[key] || ''}</td>`);
                html += `<td><strong>${row['é¢„æµ‹ç±»åˆ«']}</strong></td><td>${row['ç½®ä¿¡åº¦']}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            container.innerHTML = '<h4>é¢„æµ‹ç»“æœé¢„è§ˆ</h4>' + html;
        }
        
        // ä¸‹è½½ç»“æœCSV
        function downloadPredictions() {
            if (predictionResults.length === 0) {
                alert('è¯·å…ˆæ‰§è¡Œé¢„æµ‹');
                return;
            }
            
            const csv = Papa.unparse(predictionResults);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'predictions.csv';
            link.click();
        }
        
        // æ˜¾ç¤ºæ··æ·†çŸ©é˜µ (ä½¿ç”¨éªŒè¯é›†)
        async function showConfusionMatrix() {
            // ç®€å•æ¨¡æ‹ŸéªŒè¯é›† (æœ€å20%è®­ç»ƒæ•°æ®)
            const valSize = Math.floor(trainData.x.length * 0.2);
            const valX = trainData.x.slice(-valSize);
            const valY = trainData.y.slice(-valSize);
            
            const xsVal = tf.tensor2d(valX);
            const predictions = model.predict(xsVal);
            const predictedClasses = predictions.argMax(-1);
            const predArray = await predictedClasses.data();
            
            const matrix = Array(numClasses).fill(0).map(() => Array(numClasses).fill(0));
            
            for (let i = 0; i < valY.length; i++) {
                matrix[valY[i]][predArray[i]]++;
            }
            
            const container = document.getElementById('confusionContainer');
            container.style.display = 'block';
            
            const ctx = document.getElementById('confusionChart').getContext('2d');
            const canvas = document.getElementById('confusionChart');
            canvas.width = 400;
            canvas.height = 400;
            
            const cellSize = 400 / numClasses;
            const maxVal = Math.max(...matrix.flat());
            
            ctx.clearRect(0, 0, 400, 400);
            
            for (let i = 0; i < numClasses; i++) {
                for (let j = 0; j < numClasses; j++) {
                    const value = matrix[i][j];
                    const intensity = maxVal > 0 ? value / maxVal : 0;
                    
                    ctx.fillStyle = `rgba(102, 126, 234, ${intensity})`;
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    
                    ctx.fillStyle = intensity > 0.5 ? '#fff' : '#333';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(value, j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
                }
            }
            
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            for (let i = 0; i < numClasses; i++) {
                ctx.fillText(`é¢„æµ‹: ${i}`, i * cellSize + cellSize / 2, 400 - 10);
                ctx.save();
                ctx.translate(10, i * cellSize + cellSize / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(`çœŸå®: ${i}`, 0, 0);
                ctx.restore();
            }
            
            xsVal.dispose();
            predictions.dispose();
            predictedClasses.dispose();
        }
    </script>
</body>
</html>