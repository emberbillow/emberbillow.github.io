<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¥ç»ç½‘ç»œåˆ†ç±»å™¨</title>
    <!-- FIXED: æ›´æ–°åˆ°æœ€æ–° TF.js ç‰ˆæœ¬ï¼Œå¯èƒ½ä¿®å¤ dtype bug -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <style>
        /* æ ·å¼ä¸å˜ï¼Œç•¥... (ä¸ä¹‹å‰ç›¸åŒ) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 32px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 2px solid #e9ecef;
        }
        
        .section h2 {
            color: #495057;
            font-size: 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .control-group input, .control-group select {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .control-group small {
            color: #6c757d;
            margin-top: 5px;
            font-size: 12px;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover:not(:disabled) {
            background: #c82333;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }
        
        .chart-container h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 16px;
            text-align: center;
        }
        
        canvas {
            max-width: 100%;
            height: auto !important;
        }
        
        .status {
            background: #d1ecf1;
            border: 2px solid #bee5eb;
            color: #0c5460;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .status.training {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }
        
        .status.success {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e9ecef;
        }
        
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        .data-preview {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
        }
        
        .data-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .data-preview th, .data-preview td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        
        .data-preview th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .predict-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            margin-top: 15px;
        }
        
        .predict-result {
            margin-top: 15px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
        }
        
        .predict-result .class-label {
            font-size: 32px;
            font-weight: 700;
            color: #667eea;
            margin: 10px 0;
        }
        
        .predict-result .confidence {
            font-size: 18px;
            color: #6c757d;
        }
        
        .prob-bars {
            margin-top: 15px;
        }
        
        .prob-bar {
            margin-bottom: 10px;
        }
        
        .prob-bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
            color: #495057;
        }
        
        .prob-bar-fill {
            height: 24px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .prob-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .visualization-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script>
        // å°è¯•ä½¿ç”¨WebGLåŠ é€Ÿè®­ç»ƒï¼ˆå¦‚æœæµè§ˆå™¨æ”¯æŒï¼‰
        if (typeof tf !== 'undefined') {
            tf.setBackend('webgl').then(() => console.log('Using WebGL backend for faster training'));
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>ğŸ§  ç¥ç»ç½‘ç»œåˆ†ç±»å™¨è®­ç»ƒå¹³å°</h1>
        <p class="subtitle">åŸºäºTensorFlow.jsçš„å…¨è¿æ¥ç¥ç»ç½‘ç»œ - äº¤äº’å¼è®­ç»ƒä¸é¢„æµ‹</p>
        
        <!-- æ•°æ®ç”Ÿæˆï¼ˆæ–°å¢å¯¼å‡ºæŒ‰é’®ï¼‰ -->
        <div class="section">
            <h2>ğŸ“Š æ­¥éª¤1: æ•°æ®ç”Ÿæˆ</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>æ•°æ®é›†ç±»å‹</label>
                    <select id="datasetType">
                        <option value="iris">é¸¢å°¾èŠ±åˆ†ç±» (3ç±»)</option>
                        <option value="circles">åŒå¿ƒåœ†åˆ†ç±» (2ç±»)</option>
                        <option value="spiral">èºæ—‹åˆ†ç±» (3ç±»)</option>
                        <option value="xor">XORé—®é¢˜ (2ç±»)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>è®­ç»ƒæ ·æœ¬æ•°</label>
                    <input type="number" id="trainSamples" value="300" min="50" max="2000">
                </div>
                <div class="control-group">
                    <label>æµ‹è¯•æ ·æœ¬æ•°</label>
                    <input type="number" id="testSamples" value="100" min="20" max="500">
                </div>
                <div class="control-group">
                    <label>å™ªå£°æ°´å¹³</label>
                    <input type="number" id="noiseLevel" value="0.1" min="0" max="0.5" step="0.05">
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="generateData()">ç”Ÿæˆæ•°æ®é›†</button>
                <button class="btn-secondary" onclick="exportData()" id="exportBtn" disabled>å¯¼å‡ºæ•°æ® (CSV)</button>
            </div>
            <div id="dataStatus" style="display: none;" class="status"></div>
            <div id="dataPreview" class="data-preview" style="display: none;"></div>
        </div>
        
        <!-- æ¨¡å‹é…ç½®ï¼ˆä¸å˜ï¼Œçµæ´»éšè—å±‚ï¼‰ -->
        <div class="section">
            <h2>âš™ï¸ æ­¥éª¤2: æ¨¡å‹é…ç½®</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>éšè—å±‚èŠ‚ç‚¹æ•° (JSONæ•°ç»„)<br><small>ä¾‹: [64, 32, 16] (1-5å±‚)</small></label>
                    <input type="text" id="hiddenLayers" value="[64, 32]" placeholder="[64, 32]">
                </div>
                <div class="control-group">
                    <label>æ¿€æ´»å‡½æ•°</label>
                    <select id="activation">
                        <option value="relu">ReLU</option>
                        <option value="tanh">Tanh</option>
                        <option value="sigmoid">Sigmoid</option>
                        <option value="elu">ELU</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Dropoutç‡</label>
                    <input type="number" id="dropout" value="0.2" min="0" max="0.5" step="0.1">
                </div>
                <div class="control-group">
                    <label>å­¦ä¹ ç‡</label>
                    <input type="number" id="learningRate" value="0.01" min="0.001" max="0.1" step="0.001">
                </div>
                <div class="control-group">
                    <label>ä¼˜åŒ–å™¨</label>
                    <select id="optimizer">
                        <option value="adam">Adam</option>
                        <option value="sgd">SGD</option>
                        <option value="rmsprop">RMSprop</option>
                    </select>
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="buildModel()" id="buildBtn" disabled>æ„å»ºæ¨¡å‹</button>
            </div>
            <div id="modelStatus" style="display: none;" class="status"></div>
        </div>
        
        <!-- è®­ç»ƒï¼ˆä¸å˜ï¼‰ -->
        <div class="section">
            <h2>ğŸ¯ æ­¥éª¤3: æ¨¡å‹è®­ç»ƒ</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label>è®­ç»ƒè½®æ•° (Epochs)</label>
                    <input type="number" id="epochs" value="50" min="10" max="500">
                </div>
                <div class="control-group">
                    <label>æ‰¹æ¬¡å¤§å° (Batch Size)</label>
                    <input type="number" id="batchSize" value="32" min="8" max="128">
                </div>
            </div>
            <div class="button-group">
                <button class="btn-success" onclick="trainModel()" id="trainBtn" disabled>å¼€å§‹è®­ç»ƒ</button>
                <button class="btn-danger" onclick="stopTraining()" id="stopBtn" disabled>åœæ­¢è®­ç»ƒ</button>
            </div>
            <div id="trainingStatus" style="display: none;" class="status training"></div>
            <div class="metrics" id="metricsContainer" style="display: none;"></div>
            
            <div class="visualization-grid">
                <div class="chart-container" id="lossChartContainer" style="display: none;">
                    <h3>æŸå¤±æ›²çº¿</h3>
                    <canvas id="lossChart"></canvas>
                </div>
                <div class="chart-container" id="accChartContainer" style="display: none;">
                    <h3>å‡†ç¡®ç‡æ›²çº¿</h3>
                    <canvas id="accChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- é¢„æµ‹ï¼ˆä¸å˜ï¼‰ -->
        <div class="section">
            <h2>ğŸ”® æ­¥éª¤4: æ¨¡å‹é¢„æµ‹</h2>
            <div class="predict-section">
                <p style="color: #6c757d; margin-bottom: 15px;">è¾“å…¥ç‰¹å¾å€¼è¿›è¡Œé¢„æµ‹ (æ•°å€¼èŒƒå›´: -5 åˆ° 5)</p>
                <div class="controls-grid" id="predictInputs"></div>
                <div class="button-group">
                    <button class="btn-primary" onclick="makePrediction()" id="predictBtn" disabled>æ‰§è¡Œé¢„æµ‹</button>
                    <button class="btn-secondary" onclick="randomPredict()">éšæœºæµ‹è¯•</button>
                </div>
                <div id="predictResult" class="predict-result" style="display: none;"></div>
            </div>
        </div>
        
        <!-- å¯è§†åŒ–ï¼ˆä¸å˜ï¼‰ -->
        <div class="section">
            <h2>ğŸ“ˆ æ•°æ®å¯è§†åŒ–</h2>
            <div class="visualization-grid">
                <div class="chart-container" id="dataVizContainer" style="display: none;">
                    <h3>è®­ç»ƒæ•°æ®åˆ†å¸ƒ</h3>
                    <canvas id="dataVizChart"></canvas>
                </div>
                <div class="chart-container" id="confusionContainer" style="display: none;">
                    <h3>æ··æ·†çŸ©é˜µ</h3>
                    <canvas id="confusionChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let model = null;
        let trainData = null;
        let testData = null;
        let numFeatures = 2;
        let numClasses = 2;
        let isTraining = false;
        let stopTrainingFlag = false;
        let lossChart = null;
        let accChart = null;
        
        // æ•°æ®ç”Ÿæˆå‡½æ•°ï¼ˆä¸å˜ï¼Œç•¥... generateIrisData ç­‰ï¼‰
        function generateData() {
            const datasetType = document.getElementById('datasetType').value;
            const trainSamples = parseInt(document.getElementById('trainSamples').value);
            const testSamples = parseInt(document.getElementById('testSamples').value);
            const noise = parseFloat(document.getElementById('noiseLevel').value);
            
            let data;
            switch(datasetType) {
                case 'iris':
                    data = generateIrisData(trainSamples, testSamples, noise);
                    numFeatures = 4;
                    numClasses = 3;
                    break;
                case 'circles':
                    data = generateCirclesData(trainSamples, testSamples, noise);
                    numFeatures = 2;
                    numClasses = 2;
                    break;
                case 'spiral':
                    data = generateSpiralData(trainSamples, testSamples, noise);
                    numFeatures = 2;
                    numClasses = 3;
                    break;
                case 'xor':
                    data = generateXORData(trainSamples, testSamples, noise);
                    numFeatures = 2;
                    numClasses = 2;
                    break;
            }
            
            trainData = data.train;
            testData = data.test;
            
            document.getElementById('dataStatus').style.display = 'block';
            document.getElementById('dataStatus').className = 'status success';
            document.getElementById('dataStatus').innerHTML = `
                âœ… æ•°æ®ç”ŸæˆæˆåŠŸï¼<br>
                è®­ç»ƒé›†: ${trainSamples} æ ·æœ¬, æµ‹è¯•é›†: ${testSamples} æ ·æœ¬<br>
                ç‰¹å¾ç»´åº¦: ${numFeatures}, ç±»åˆ«æ•°: ${numClasses}
            `;
            
            showDataPreview();
            visualizeData();
            
            document.getElementById('buildBtn').disabled = false;
            document.getElementById('exportBtn').disabled = false; // æ–°å¢ï¼šå¯ç”¨å¯¼å‡ºæŒ‰é’®
            setupPredictInputs();
        }
        
        // æ–°å¢ï¼šå¯¼å‡ºæ•°æ®åŠŸèƒ½ (CSVæ ¼å¼)
        function exportData() {
            if (!trainData || !testData) {
                alert('è¯·å…ˆç”Ÿæˆæ•°æ®');
                return;
            }

            const datasetType = document.getElementById('datasetType').value;
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);

            // ç”ŸæˆCSVå†…å®¹
            let csv = `# Dataset Type: ${datasetType}\n`;
            csv += `# Number of Features: ${numFeatures}\n`;
            csv += `# Number of Classes: ${numClasses}\n`;
            csv += `# Train Samples: ${trainData.x.length}\n`;
            csv += `# Test Samples: ${testData.x.length}\n`;
            csv += `# Noise Level: ${noiseLevel}\n\n`;
            
            // è¡¨å¤´
            csv += 'set,class';
            for (let i = 1; i <= numFeatures; i++) {
                csv += `,feature${i}`;
            }
            csv += '\n';
            
            // è®­ç»ƒé›†æ•°æ®
            trainData.x.forEach((features, index) => {
                csv += `train,${trainData.y[index]}`;
                features.forEach(f => csv += `,${f.toFixed(6)}`);
                csv += '\n';
            });
            
            // æµ‹è¯•é›†æ•°æ®
            testData.x.forEach((features, index) => {
                csv += `test,${testData.y[index]}`;
                features.forEach(f => csv += `,${f.toFixed(6)}`);
                csv += '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `dataset_${datasetType}_${Date.now()}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // æ˜¾ç¤ºå¯¼å‡ºæˆåŠŸæ¶ˆæ¯
            const status = document.getElementById('dataStatus');
            status.className = 'status success';
            status.innerHTML += '<br>ğŸ“ æ•°æ®å·²å¯¼å‡ºä¸º CSV æ–‡ä»¶ï¼';
        }
        
        // generateIrisData ç­‰å‡½æ•°ä¸å˜ï¼Œç•¥...
        function generateIrisData(nTrain, nTest, noise) {
            const train = { x: [], y: [] };
            const test = { x: [], y: [] };
            
            const centers = [
                [5.0, 3.5, 1.5, 0.3],
                [6.0, 2.8, 4.5, 1.5],
                [6.5, 3.0, 5.5, 2.0]
            ];
            
            for (let i = 0; i < nTrain; i++) {
                const classIdx = Math.floor(Math.random() * 3);
                const features = centers[classIdx].map(c => c + (Math.random() - 0.5) * noise * 2);
                train.x.push(features);
                train.y.push(classIdx);
            }
            
            for (let i = 0; i < nTest; i++) {
                const classIdx = Math.floor(Math.random() * 3);
                const features = centers[classIdx].map(c => c + (Math.random() - 0.5) * noise * 2);
                test.x.push(features);
                test.y.push(classIdx);
            }
            
            return { train, test };
        }
        
        function generateCirclesData(nTrain, nTest, noise) {
            const train = { x: [], y: [] };
            const test = { x: [], y: [] };
            
            const generate = (n, dataset) => {
                for (let i = 0; i < n; i++) {
                    const classIdx = Math.random() > 0.5 ? 1 : 0;
                    const r = classIdx === 0 ? Math.random() * 1.5 : Math.random() * 1.5 + 2;
                    const theta = Math.random() * 2 * Math.PI;
                    const x = r * Math.cos(theta) + (Math.random() - 0.5) * noise;
                    const y = r * Math.sin(theta) + (Math.random() - 0.5) * noise;
                    dataset.x.push([x, y]);
                    dataset.y.push(classIdx);
                }
            };
            
            generate(nTrain, train);
            generate(nTest, test);
            
            return { train, test };
        }
        
        function generateSpiralData(nTrain, nTest, noise) {
            const train = { x: [], y: [] };
            const test = { x: [], y: [] };
            
            const generate = (n, dataset) => {
                const samplesPerClass = Math.floor(n / 3);
                for (let c = 0; c < 3; c++) {
                    for (let i = 0; i < samplesPerClass; i++) {
                        const r = i / samplesPerClass * 3;
                        const t = i / samplesPerClass * 2 * Math.PI + c * 2 * Math.PI / 3;
                        const x = r * Math.cos(t) + (Math.random() - 0.5) * noise;
                        const y = r * Math.sin(t) + (Math.random() - 0.5) * noise;
                        dataset.x.push([x, y]);
                        dataset.y.push(c);
                    }
                }
            };
            
            generate(nTrain, train);
            generate(nTest, test);
            
            return { train, test };
        }
        
        function generateXORData(nTrain, nTest, noise) {
            const train = { x: [], y: [] };
            const test = { x: [], y: [] };
            
            const generate = (n, dataset) => {
                for (let i = 0; i < n; i++) {
                    const x1 = Math.random() * 4 - 2;
                    const x2 = Math.random() * 4 - 2;
                    const label = (x1 > 0) !== (x2 > 0) ? 1 : 0;
                    const x1n = x1 + (Math.random() - 0.5) * noise;
                    const x2n = x2 + (Math.random() - 0.5) * noise;
                    dataset.x.push([x1n, x2n]);
                    dataset.y.push(label);
                }
            };
            
            generate(nTrain, train);
            generate(nTest, test);
            
            return { train, test };
        }
        
        function showDataPreview() {
            const preview = document.getElementById('dataPreview');
            preview.style.display = 'block';
            
            let html = '<table><thead><tr>';
            for (let i = 0; i < numFeatures; i++) {
                html += `<th>ç‰¹å¾${i + 1}</th>`;
            }
            html += '<th>ç±»åˆ«</th></tr></thead><tbody>';
            
            for (let i = 0; i < Math.min(10, trainData.x.length); i++) {
                html += '<tr>';
                for (let j = 0; j < numFeatures; j++) {
                    html += `<td>${trainData.x[i][j].toFixed(3)}</td>`;
                }
                html += `<td><strong>${trainData.y[i]}</strong></td></tr>`;
            }
            
            html += '</tbody></table>';
            preview.innerHTML = html;
        }
        
        function visualizeData() {
            if (numFeatures !== 2) return;
            
            const container = document.getElementById('dataVizContainer');
            container.style.display = 'block';
            
            const ctx = document.getElementById('dataVizChart').getContext('2d');
            
            const colors = ['rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 206, 86)'];
            const datasets = [];
            
            for (let c = 0; c < numClasses; c++) {
                const points = trainData.x.filter((_, i) => trainData.y[i] === c)
                    .map(p => ({ x: p[0], y: p[1] }));
                
                datasets.push({
                    label: `ç±»åˆ« ${c}`,
                    data: points,
                    backgroundColor: colors[c],
                    pointRadius: 4
                });
            }
            
            new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: { title: { display: true, text: 'ç‰¹å¾1' } },
                        y: { title: { display: true, text: 'ç‰¹å¾2' } }
                    }
                }
            });
        }
        
        // FIXED: æ„å»ºæ¨¡å‹ - åˆ‡æ¢åˆ° categoricalCrossentropyï¼Œé¿å… int32 dtype é—®é¢˜
        function buildModel() {
            try {
                const hiddenLayersStr = document.getElementById('hiddenLayers').value.trim();
                let hiddenLayers = [64, 32]; // é»˜è®¤
                if (hiddenLayersStr) {
                    hiddenLayers = JSON.parse(hiddenLayersStr);
                    if (!Array.isArray(hiddenLayers) || hiddenLayers.length === 0 || hiddenLayers.length > 5) {
                        throw new Error('æ— æ•ˆæ•°ç»„ï¼šå¿…é¡»æ˜¯1-5ä¸ªæ­£æ•´æ•°');
                    }
                    hiddenLayers = hiddenLayers.map(u => Math.max(8, Math.min(256, parseInt(u)))); // é™åˆ¶èŒƒå›´
                }
                
                const activation = document.getElementById('activation').value;
                const dropout = parseFloat(document.getElementById('dropout').value);
                const learningRate = parseFloat(document.getElementById('learningRate').value);
                const optimizerType = document.getElementById('optimizer').value;
                
                model = tf.sequential();
                
                // è¾“å…¥å±‚ + ç¬¬ä¸€ä¸ªéšè—å±‚
                model.add(tf.layers.dense({
                    units: hiddenLayers[0],
                    activation: activation,
                    inputShape: [numFeatures]
                }));
                model.add(tf.layers.dropout({ rate: dropout }));
                
                // åç»­éšè—å±‚
                for (let i = 1; i < hiddenLayers.length; i++) {
                    model.add(tf.layers.dense({
                        units: hiddenLayers[i],
                        activation: activation
                    }));
                    model.add(tf.layers.dropout({ rate: dropout }));
                }
                
                // è¾“å‡ºå±‚
                model.add(tf.layers.dense({
                    units: numClasses,
                    activation: 'softmax'
                }));
                
                // é…ç½®ä¼˜åŒ–å™¨
                let optimizer;
                switch(optimizerType) {
                    case 'adam':
                        optimizer = tf.train.adam(learningRate);
                        break;
                    case 'sgd':
                        optimizer = tf.train.sgd(learningRate);
                        break;
                    case 'rmsprop':
                        optimizer = tf.train.rmsprop(learningRate);
                        break;
                }
                
                // FIXED: ä½¿ç”¨ categoricalCrossentropyï¼ˆone-hot labelsï¼‰ï¼Œé¿å… int32 floor é”™è¯¯
                model.compile({
                    optimizer: optimizer,
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                
                // æ‰“å°æ¨¡å‹æ‘˜è¦åˆ°Console
                model.summary();
                
                document.getElementById('modelStatus').style.display = 'block';
                document.getElementById('modelStatus').className = 'status success';
                document.getElementById('modelStatus').innerHTML = `
                    âœ… æ¨¡å‹æ„å»ºæˆåŠŸï¼<br>
                    éšè—å±‚: [${hiddenLayers.join(' â†’ ')}]<br>
                    æ€»å‚æ•°: ${model.countParams()} | æŸå¤±: categoricalCrossentropy
                `;
                
                document.getElementById('trainBtn').disabled = false;
            } catch (error) {
                document.getElementById('modelStatus').style.display = 'block';
                document.getElementById('modelStatus').className = 'status error';
                document.getElementById('modelStatus').innerHTML = `âŒ æ„å»ºå¤±è´¥: ${error.message}`;
                console.error(error);
            }
        }
        
        // FIXED: è®­ç»ƒæ¨¡å‹ - ä½¿ç”¨ one-hot æ ‡ç­¾ (float32)ï¼Œä¿®å¤ dtype é—®é¢˜
        async function trainModel() {
            if (!model || !trainData) {
                alert('è¯·å…ˆç”Ÿæˆæ•°æ®å¹¶æ„å»ºæ¨¡å‹');
                return;
            }
            
            try {
                isTraining = true;
                stopTrainingFlag = false;
                document.getElementById('trainBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('buildBtn').disabled = true;
                
                const epochs = parseInt(document.getElementById('epochs').value);
                const batchSize = parseInt(document.getElementById('batchSize').value);
                
                document.getElementById('trainingStatus').style.display = 'block';
                document.getElementById('trainingStatus').innerHTML = 'ğŸ”„ åˆå§‹åŒ–è®­ç»ƒ...';
                document.getElementById('metricsContainer').style.display = 'grid';
                document.getElementById('lossChartContainer').style.display = 'block';
                document.getElementById('accChartContainer').style.display = 'block';
                
                // å‡†å¤‡æ•°æ®
                const xsTrain = tf.tensor2d(trainData.x);
                // FIXED: è½¬æ¢ä¸º one-hot (float32)ï¼ŒåŒ¹é… categoricalCrossentropy
                const ysTrainLabels = tf.tensor1d(trainData.y, 'int32');
                const ysTrain = tf.oneHot(ysTrainLabels, numClasses);
                
                const xsTest = tf.tensor2d(testData.x);
                const ysTestLabels = tf.tensor1d(testData.y, 'int32');
                const ysTest = tf.oneHot(ysTestLabels, numClasses);
                
                // åˆå§‹åŒ–å›¾è¡¨
                const lossData = { train: [], test: [] };
                const accData = { train: [], test: [] };
                
                setupCharts();
                
                // è®­ç»ƒå¾ªç¯
                for (let epoch = 0; epoch < epochs; epoch++) {
                    if (stopTrainingFlag) break;
                    
                    const history = await model.fit(xsTrain, ysTrain, {
                        batchSize: batchSize,
                        epochs: 1,
                        validationData: [xsTest, ysTest],
                        verbose: 0
                    });
                    
                    const trainLoss = history.history.loss[0];
                    const trainAcc = history.history.acc[0];
                    const testLoss = history.history.val_loss[0];
                    const testAcc = history.history.val_acc[0];
                    
                    lossData.train.push(trainLoss);
                    lossData.test.push(testLoss);
                    accData.train.push(trainAcc);
                    accData.test.push(testAcc);
                    
                    updateCharts(lossData, accData);
                    updateMetrics(trainLoss, trainAcc, testLoss, testAcc);
                    
                    const progress = ((epoch + 1) / epochs * 100).toFixed(1);
                    document.getElementById('trainingStatus').innerHTML = `
                        ğŸ”„ æ­£åœ¨è®­ç»ƒ... Epoch ${epoch + 1}/${epochs} (${progress}%)<br>
                        è®­ç»ƒæŸå¤±: ${trainLoss.toFixed(4)} | è®­ç»ƒå‡†ç¡®ç‡: ${(trainAcc * 100).toFixed(2)}%<br>
                        æµ‹è¯•æŸå¤±: ${testLoss.toFixed(4)} | æµ‹è¯•å‡†ç¡®ç‡: ${(testAcc * 100).toFixed(2)}%
                    `;
                    
                    if ((epoch + 1) % 5 === 0 || epoch === epochs - 1) {
                        await new Promise(resolve => requestAnimationFrame(resolve));
                    } else {
                        await tf.nextFrame();
                    }
                    
                    // æ¸…ç†å• epoch å†å²
                    Object.keys(history.history).forEach(key => history.history[key].length = 0);
                }
                
                // è®­ç»ƒå®Œæˆ
                xsTrain.dispose();
                ysTrain.dispose();
                ysTrainLabels.dispose();
                xsTest.dispose();
                ysTest.dispose();
                ysTestLabels.dispose();
                
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('buildBtn').disabled = false;
                document.getElementById('predictBtn').disabled = false;
                
                if (!stopTrainingFlag) {
                    document.getElementById('trainingStatus').className = 'status success';
                    document.getElementById('trainingStatus').innerHTML = `
                        âœ… è®­ç»ƒå®Œæˆï¼<br>
                        æœ€ç»ˆæµ‹è¯•å‡†ç¡®ç‡: ${(accData.test[accData.test.length - 1] * 100).toFixed(2)}%
                    `;
                    
                    showConfusionMatrix();
                } else {
                    document.getElementById('trainingStatus').innerHTML = 'âš ï¸ è®­ç»ƒå·²åœæ­¢';
                }
            } catch (error) {
                console.error('è®­ç»ƒé”™è¯¯:', error);
                document.getElementById('trainingStatus').className = 'status error';
                document.getElementById('trainingStatus').innerHTML = `âŒ è®­ç»ƒå¤±è´¥: ${error.message}`;
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        function stopTraining() {
            stopTrainingFlag = true;
            document.getElementById('stopBtn').disabled = true;
        }
        
        // setupCharts, updateCharts, updateMetrics ä¸å˜ï¼Œç•¥...
        function setupCharts() {
            const lossCtx = document.getElementById('lossChart').getContext('2d');
            const accCtx = document.getElementById('accChart').getContext('2d');
            
            if (lossChart) lossChart.destroy();
            if (accChart) accChart.destroy();
            
            lossChart = new Chart(lossCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'è®­ç»ƒæŸå¤±',
                            data: [],
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'æµ‹è¯•æŸå¤±',
                            data: [],
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1.5,
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { title: { display: true, text: 'Epoch' } },
                        y: { title: { display: true, text: 'Loss' }, beginAtZero: true }
                    }
                }
            });
            
            accChart = new Chart(accCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'è®­ç»ƒå‡†ç¡®ç‡',
                            data: [],
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'æµ‹è¯•å‡†ç¡®ç‡',
                            data: [],
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1.5,
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { title: { display: true, text: 'Epoch' } },
                        y: { title: { display: true, text: 'Accuracy' }, beginAtZero: true, max: 1 }
                    }
                }
            });
        }
        
        function updateCharts(lossData, accData) {
            const epochs = lossData.train.length;
            const labels = Array.from({ length: epochs }, (_, i) => i + 1);
            
            lossChart.data.labels = labels;
            lossChart.data.datasets[0].data = lossData.train;
            lossChart.data.datasets[1].data = lossData.test;
            lossChart.update('none');
            
            accChart.data.labels = labels;
            accChart.data.datasets[0].data = accData.train;
            accChart.data.datasets[1].data = accData.test;
            accChart.update('none');
        }
        
        function updateMetrics(trainLoss, trainAcc, testLoss, testAcc) {
            document.getElementById('metricsContainer').innerHTML = `
                <div class="metric-card">
                    <div class="metric-label">è®­ç»ƒæŸå¤±</div>
                    <div class="metric-value">${trainLoss.toFixed(4)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">è®­ç»ƒå‡†ç¡®ç‡</div>
                    <div class="metric-value">${(trainAcc * 100).toFixed(2)}%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">æµ‹è¯•æŸå¤±</div>
                    <div class="metric-value">${testLoss.toFixed(4)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">æµ‹è¯•å‡†ç¡®ç‡</div>
                    <div class="metric-value">${(testAcc * 100).toFixed(2)}%</div>
                </div>
            `;
        }
        
        // å…¶ä»–å‡½æ•°ä¸å˜ï¼šsetupPredictInputs, makePrediction, randomPredict, displayPrediction, showConfusionMatrix
        function setupPredictInputs() {
            const container = document.getElementById('predictInputs');
            let html = '';
            
            const featureNames = numFeatures === 4 
                ? ['èŠ±è¼é•¿åº¦', 'èŠ±è¼å®½åº¦', 'èŠ±ç“£é•¿åº¦', 'èŠ±ç“£å®½åº¦']
                : Array.from({ length: numFeatures }, (_, i) => `ç‰¹å¾${i + 1}`);
            
            for (let i = 0; i < numFeatures; i++) {
                html += `
                    <div class="control-group">
                        <label>${featureNames[i]}</label>
                        <input type="number" id="feature${i}" value="0" step="0.1">
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        async function makePrediction() {
            if (!model) return;
            
            const features = [];
            for (let i = 0; i < numFeatures; i++) {
                features.push(parseFloat(document.getElementById(`feature${i}`).value));
            }
            
            const input = tf.tensor2d([features]);
            const prediction = model.predict(input);
            const probabilities = await prediction.data();
            
            const predictedClass = probabilities.indexOf(Math.max(...probabilities));
            const confidence = probabilities[predictedClass];
            
            displayPrediction(predictedClass, confidence, probabilities);
            
            input.dispose();
            prediction.dispose();
        }
        
        function randomPredict() {
            if (!testData) return;
            
            const idx = Math.floor(Math.random() * testData.x.length);
            const sample = testData.x[idx];
            
            for (let i = 0; i < numFeatures; i++) {
                document.getElementById(`feature${i}`).value = sample[i].toFixed(3);
            }
            
            makePrediction();
        }
        
        function displayPrediction(classIdx, confidence, probabilities) {
            const result = document.getElementById('predictResult');
            result.style.display = 'block';
            
            let html = `
                <div class="class-label">ç±»åˆ«: ${classIdx}</div>
                <div class="confidence">ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(2)}%</div>
                <div class="prob-bars">
            `;
            
            for (let i = 0; i < numClasses; i++) {
                const prob = probabilities[i];
                html += `
                    <div class="prob-bar">
                        <div class="prob-bar-label">
                            <span>ç±»åˆ« ${i}</span>
                            <span>${(prob * 100).toFixed(2)}%</span>
                        </div>
                        <div class="prob-bar-fill">
                            <div class="prob-bar-inner" style="width: ${prob * 100}%">
                                ${prob > 0.1 ? (prob * 100).toFixed(1) + '%' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            result.innerHTML = html;
        }
        
        async function showConfusionMatrix() {
            if (!model || !testData) return;
            
            const container = document.getElementById('confusionContainer');
            container.style.display = 'block';
            
            const xsTest = tf.tensor2d(testData.x);
            const predictions = model.predict(xsTest);
            const predictedClasses = predictions.argMax(-1);
            const predArray = await predictedClasses.data();
            
            // FIXED: trueClass ä»ä½¿ç”¨åŸå§‹æ•°ç»„ (int)ï¼Œæ— éœ€å˜åŒ–
            const matrix = Array(numClasses).fill(0).map(() => Array(numClasses).fill(0));
            
            for (let i = 0; i < testData.y.length; i++) {
                const trueClass = testData.y[i];
                const predClass = predArray[i];
                matrix[trueClass][predClass]++;
            }
            
            const ctx = document.getElementById('confusionChart').getContext('2d');
            const canvas = document.getElementById('confusionChart');
            canvas.width = 400;
            canvas.height = 400;
            
            const cellSize = 400 / numClasses;
            const maxVal = Math.max(...matrix.flat());
            
            ctx.clearRect(0, 0, 400, 400);
            
            for (let i = 0; i < numClasses; i++) {
                for (let j = 0; j < numClasses; j++) {
                    const value = matrix[i][j];
                    const intensity = value / maxVal;
                    
                    ctx.fillStyle = `rgba(102, 126, 234, ${intensity})`;
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    
                    ctx.fillStyle = intensity > 0.5 ? '#fff' : '#333';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(value, j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
                }
            }
            
            // æ·»åŠ æ ‡ç­¾
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            for (let i = 0; i < numClasses; i++) {
                ctx.fillText(`é¢„æµ‹: ${i}`, i * cellSize + cellSize / 2, 400 - 10);
                ctx.save();
                ctx.translate(10, i * cellSize + cellSize / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(`çœŸå®: ${i}`, 0, 0);
                ctx.restore();
            }
            
            xsTest.dispose();
            predictions.dispose();
            predictedClasses.dispose();
        }
    </script>
</body>
</html>